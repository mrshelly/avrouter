// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class client_hello;
class server_hello;
class login;
class login_result;
class user_register;

enum login_result_login_result_code {
  login_result_login_result_code_LOGIN_SUCCEED = 0,
  login_result_login_result_code_NO_SUCH_USER = 1,
  login_result_login_result_code_PEREMISSON_DENIED = 2,
  login_result_login_result_code_PUBLIC_KEY_MISMATCH = 3
};
bool login_result_login_result_code_IsValid(int value);
const login_result_login_result_code login_result_login_result_code_login_result_code_MIN = login_result_login_result_code_LOGIN_SUCCEED;
const login_result_login_result_code login_result_login_result_code_login_result_code_MAX = login_result_login_result_code_PUBLIC_KEY_MISMATCH;
const int login_result_login_result_code_login_result_code_ARRAYSIZE = login_result_login_result_code_login_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* login_result_login_result_code_descriptor();
inline const ::std::string& login_result_login_result_code_Name(login_result_login_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    login_result_login_result_code_descriptor(), value);
}
inline bool login_result_login_result_code_Parse(
    const ::std::string& name, login_result_login_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<login_result_login_result_code>(
    login_result_login_result_code_descriptor(), name, value);
}
// ===================================================================

class client_hello : public ::google::protobuf::Message {
 public:
  client_hello();
  virtual ~client_hello();

  client_hello(const client_hello& from);

  inline client_hello& operator=(const client_hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_hello& default_instance();

  void Swap(client_hello* other);

  // implements Message ----------------------------------------------

  client_hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_hello& from);
  void MergeFrom(const client_hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::std::string& client() const;
  inline void set_client(const ::std::string& value);
  inline void set_client(const char* value);
  inline void set_client(const char* value, size_t size);
  inline ::std::string* mutable_client();
  inline ::std::string* release_client();
  inline void set_allocated_client(::std::string* client);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional bytes random_key = 3;
  inline bool has_random_key() const;
  inline void clear_random_key();
  static const int kRandomKeyFieldNumber = 3;
  inline const ::std::string& random_key() const;
  inline void set_random_key(const ::std::string& value);
  inline void set_random_key(const char* value);
  inline void set_random_key(const void* value, size_t size);
  inline ::std::string* mutable_random_key();
  inline ::std::string* release_random_key();
  inline void set_allocated_random_key(::std::string* random_key);

  // @@protoc_insertion_point(class_scope:proto.client_hello)
 private:
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_key();
  inline void clear_has_random_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_;
  ::std::string* random_key_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static client_hello* default_instance_;
};
// -------------------------------------------------------------------

class server_hello : public ::google::protobuf::Message {
 public:
  server_hello();
  virtual ~server_hello();

  server_hello(const server_hello& from);

  inline server_hello& operator=(const server_hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const server_hello& default_instance();

  void Swap(server_hello* other);

  // implements Message ----------------------------------------------

  server_hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const server_hello& from);
  void MergeFrom(const server_hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string servername = 1;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 1;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bytes random_key = 3;
  inline bool has_random_key() const;
  inline void clear_random_key();
  static const int kRandomKeyFieldNumber = 3;
  inline const ::std::string& random_key() const;
  inline void set_random_key(const ::std::string& value);
  inline void set_random_key(const char* value);
  inline void set_random_key(const void* value, size_t size);
  inline ::std::string* mutable_random_key();
  inline ::std::string* release_random_key();
  inline void set_allocated_random_key(::std::string* random_key);

  // @@protoc_insertion_point(class_scope:proto.server_hello)
 private:
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_key();
  inline void clear_has_random_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* servername_;
  ::std::string* random_key_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static server_hello* default_instance_;
};
// -------------------------------------------------------------------

class login : public ::google::protobuf::Message {
 public:
  login();
  virtual ~login();

  login(const login& from);

  inline login& operator=(const login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login& default_instance();

  void Swap(login* other);

  // implements Message ----------------------------------------------

  login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login& from);
  void MergeFrom(const login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required bytes encryped_radom_key = 2;
  inline bool has_encryped_radom_key() const;
  inline void clear_encryped_radom_key();
  static const int kEncrypedRadomKeyFieldNumber = 2;
  inline const ::std::string& encryped_radom_key() const;
  inline void set_encryped_radom_key(const ::std::string& value);
  inline void set_encryped_radom_key(const char* value);
  inline void set_encryped_radom_key(const void* value, size_t size);
  inline ::std::string* mutable_encryped_radom_key();
  inline ::std::string* release_encryped_radom_key();
  inline void set_allocated_encryped_radom_key(::std::string* encryped_radom_key);

  // optional string other_info = 3;
  inline bool has_other_info() const;
  inline void clear_other_info();
  static const int kOtherInfoFieldNumber = 3;
  inline const ::std::string& other_info() const;
  inline void set_other_info(const ::std::string& value);
  inline void set_other_info(const char* value);
  inline void set_other_info(const char* value, size_t size);
  inline ::std::string* mutable_other_info();
  inline ::std::string* release_other_info();
  inline void set_allocated_other_info(::std::string* other_info);

  // @@protoc_insertion_point(class_scope:proto.login)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_encryped_radom_key();
  inline void clear_has_encryped_radom_key();
  inline void set_has_other_info();
  inline void clear_has_other_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* encryped_radom_key_;
  ::std::string* other_info_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static login* default_instance_;
};
// -------------------------------------------------------------------

class login_result : public ::google::protobuf::Message {
 public:
  login_result();
  virtual ~login_result();

  login_result(const login_result& from);

  inline login_result& operator=(const login_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_result& default_instance();

  void Swap(login_result* other);

  // implements Message ----------------------------------------------

  login_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_result& from);
  void MergeFrom(const login_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef login_result_login_result_code login_result_code;
  static const login_result_code LOGIN_SUCCEED = login_result_login_result_code_LOGIN_SUCCEED;
  static const login_result_code NO_SUCH_USER = login_result_login_result_code_NO_SUCH_USER;
  static const login_result_code PEREMISSON_DENIED = login_result_login_result_code_PEREMISSON_DENIED;
  static const login_result_code PUBLIC_KEY_MISMATCH = login_result_login_result_code_PUBLIC_KEY_MISMATCH;
  static inline bool login_result_code_IsValid(int value) {
    return login_result_login_result_code_IsValid(value);
  }
  static const login_result_code login_result_code_MIN =
    login_result_login_result_code_login_result_code_MIN;
  static const login_result_code login_result_code_MAX =
    login_result_login_result_code_login_result_code_MAX;
  static const int login_result_code_ARRAYSIZE =
    login_result_login_result_code_login_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  login_result_code_descriptor() {
    return login_result_login_result_code_descriptor();
  }
  static inline const ::std::string& login_result_code_Name(login_result_code value) {
    return login_result_login_result_code_Name(value);
  }
  static inline bool login_result_code_Parse(const ::std::string& name,
      login_result_code* value) {
    return login_result_login_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.login_result.login_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::login_result_login_result_code result() const;
  inline void set_result(::proto::login_result_login_result_code value);

  // @@protoc_insertion_point(class_scope:proto.login_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static login_result* default_instance_;
};
// -------------------------------------------------------------------

class user_register : public ::google::protobuf::Message {
 public:
  user_register();
  virtual ~user_register();

  user_register(const user_register& from);

  inline user_register& operator=(const user_register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_register& default_instance();

  void Swap(user_register* other);

  // implements Message ----------------------------------------------

  user_register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_register& from);
  void MergeFrom(const user_register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required bytes rsa_pubkey = 2;
  inline bool has_rsa_pubkey() const;
  inline void clear_rsa_pubkey();
  static const int kRsaPubkeyFieldNumber = 2;
  inline const ::std::string& rsa_pubkey() const;
  inline void set_rsa_pubkey(const ::std::string& value);
  inline void set_rsa_pubkey(const char* value);
  inline void set_rsa_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_rsa_pubkey();
  inline ::std::string* release_rsa_pubkey();
  inline void set_allocated_rsa_pubkey(::std::string* rsa_pubkey);

  // optional string mail_address = 3;
  inline bool has_mail_address() const;
  inline void clear_mail_address();
  static const int kMailAddressFieldNumber = 3;
  inline const ::std::string& mail_address() const;
  inline void set_mail_address(const ::std::string& value);
  inline void set_mail_address(const char* value);
  inline void set_mail_address(const char* value, size_t size);
  inline ::std::string* mutable_mail_address();
  inline ::std::string* release_mail_address();
  inline void set_allocated_mail_address(::std::string* mail_address);

  // optional string cell_phone = 4;
  inline bool has_cell_phone() const;
  inline void clear_cell_phone();
  static const int kCellPhoneFieldNumber = 4;
  inline const ::std::string& cell_phone() const;
  inline void set_cell_phone(const ::std::string& value);
  inline void set_cell_phone(const char* value);
  inline void set_cell_phone(const char* value, size_t size);
  inline ::std::string* mutable_cell_phone();
  inline ::std::string* release_cell_phone();
  inline void set_allocated_cell_phone(::std::string* cell_phone);

  // @@protoc_insertion_point(class_scope:proto.user_register)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_rsa_pubkey();
  inline void clear_has_rsa_pubkey();
  inline void set_has_mail_address();
  inline void clear_has_mail_address();
  inline void set_has_cell_phone();
  inline void clear_has_cell_phone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* rsa_pubkey_;
  ::std::string* mail_address_;
  ::std::string* cell_phone_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_register* default_instance_;
};
// ===================================================================


// ===================================================================

// client_hello

// required string client = 1;
inline bool client_hello::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_hello::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_hello::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_hello::clear_client() {
  if (client_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_->clear();
  }
  clear_has_client();
}
inline const ::std::string& client_hello::client() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.client)
  return *client_;
}
inline void client_hello::set_client(const ::std::string& value) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  client_->assign(value);
  // @@protoc_insertion_point(field_set:proto.client_hello.client)
}
inline void client_hello::set_client(const char* value) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  client_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.client_hello.client)
}
inline void client_hello::set_client(const char* value, size_t size) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  client_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.client)
}
inline ::std::string* client_hello::mutable_client() {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.client_hello.client)
  return client_;
}
inline ::std::string* client_hello::release_client() {
  clear_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_;
    client_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_hello::set_allocated_client(::std::string* client) {
  if (client_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_;
  }
  if (client) {
    set_has_client();
    client_ = client;
  } else {
    clear_has_client();
    client_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.client)
}

// required uint32 version = 2;
inline bool client_hello::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_hello::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_hello::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 client_hello::version() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.version)
  return version_;
}
inline void client_hello::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.client_hello.version)
}

// optional bytes random_key = 3;
inline bool client_hello::has_random_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_hello::set_has_random_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_hello::clear_has_random_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_hello::clear_random_key() {
  if (random_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_->clear();
  }
  clear_has_random_key();
}
inline const ::std::string& client_hello::random_key() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_key)
  return *random_key_;
}
inline void client_hello::set_random_key(const ::std::string& value) {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  random_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_key)
}
inline void client_hello::set_random_key(const char* value) {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  random_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_key)
}
inline void client_hello::set_random_key(const void* value, size_t size) {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  random_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_key)
}
inline ::std::string* client_hello::mutable_random_key() {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_key)
  return random_key_;
}
inline ::std::string* client_hello::release_random_key() {
  clear_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = random_key_;
    random_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_hello::set_allocated_random_key(::std::string* random_key) {
  if (random_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete random_key_;
  }
  if (random_key) {
    set_has_random_key();
    random_key_ = random_key;
  } else {
    clear_has_random_key();
    random_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_key)
}

// -------------------------------------------------------------------

// server_hello

// required string servername = 1;
inline bool server_hello::has_servername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void server_hello::set_has_servername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void server_hello::clear_has_servername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void server_hello::clear_servername() {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& server_hello::servername() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.servername)
  return *servername_;
}
inline void server_hello::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set:proto.server_hello.servername)
}
inline void server_hello::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.server_hello.servername)
}
inline void server_hello::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.servername)
}
inline ::std::string* server_hello::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.server_hello.servername)
  return servername_;
}
inline ::std::string* server_hello::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void server_hello::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.servername)
}

// required uint32 version = 2;
inline bool server_hello::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void server_hello::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void server_hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void server_hello::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 server_hello::version() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.version)
  return version_;
}
inline void server_hello::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.server_hello.version)
}

// required bytes random_key = 3;
inline bool server_hello::has_random_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void server_hello::set_has_random_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void server_hello::clear_has_random_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void server_hello::clear_random_key() {
  if (random_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_->clear();
  }
  clear_has_random_key();
}
inline const ::std::string& server_hello::random_key() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.random_key)
  return *random_key_;
}
inline void server_hello::set_random_key(const ::std::string& value) {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  random_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.server_hello.random_key)
}
inline void server_hello::set_random_key(const char* value) {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  random_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.server_hello.random_key)
}
inline void server_hello::set_random_key(const void* value, size_t size) {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  random_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.random_key)
}
inline ::std::string* server_hello::mutable_random_key() {
  set_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.server_hello.random_key)
  return random_key_;
}
inline ::std::string* server_hello::release_random_key() {
  clear_has_random_key();
  if (random_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = random_key_;
    random_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void server_hello::set_allocated_random_key(::std::string* random_key) {
  if (random_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete random_key_;
  }
  if (random_key) {
    set_has_random_key();
    random_key_ = random_key;
  } else {
    clear_has_random_key();
    random_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.random_key)
}

// -------------------------------------------------------------------

// login

// required string user_name = 1;
inline bool login::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& login::user_name() const {
  // @@protoc_insertion_point(field_get:proto.login.user_name)
  return *user_name_;
}
inline void login::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:proto.login.user_name)
}
inline void login::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.login.user_name)
}
inline void login::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.login.user_name)
}
inline ::std::string* login::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.login.user_name)
  return user_name_;
}
inline ::std::string* login::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.login.user_name)
}

// required bytes encryped_radom_key = 2;
inline bool login::has_encryped_radom_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login::set_has_encryped_radom_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login::clear_has_encryped_radom_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login::clear_encryped_radom_key() {
  if (encryped_radom_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_->clear();
  }
  clear_has_encryped_radom_key();
}
inline const ::std::string& login::encryped_radom_key() const {
  // @@protoc_insertion_point(field_get:proto.login.encryped_radom_key)
  return *encryped_radom_key_;
}
inline void login::set_encryped_radom_key(const ::std::string& value) {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  encryped_radom_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.login.encryped_radom_key)
}
inline void login::set_encryped_radom_key(const char* value) {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  encryped_radom_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.login.encryped_radom_key)
}
inline void login::set_encryped_radom_key(const void* value, size_t size) {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  encryped_radom_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.login.encryped_radom_key)
}
inline ::std::string* login::mutable_encryped_radom_key() {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.login.encryped_radom_key)
  return encryped_radom_key_;
}
inline ::std::string* login::release_encryped_radom_key() {
  clear_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryped_radom_key_;
    encryped_radom_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_encryped_radom_key(::std::string* encryped_radom_key) {
  if (encryped_radom_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryped_radom_key_;
  }
  if (encryped_radom_key) {
    set_has_encryped_radom_key();
    encryped_radom_key_ = encryped_radom_key;
  } else {
    clear_has_encryped_radom_key();
    encryped_radom_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.login.encryped_radom_key)
}

// optional string other_info = 3;
inline bool login::has_other_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login::set_has_other_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login::clear_has_other_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login::clear_other_info() {
  if (other_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_->clear();
  }
  clear_has_other_info();
}
inline const ::std::string& login::other_info() const {
  // @@protoc_insertion_point(field_get:proto.login.other_info)
  return *other_info_;
}
inline void login::set_other_info(const ::std::string& value) {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  other_info_->assign(value);
  // @@protoc_insertion_point(field_set:proto.login.other_info)
}
inline void login::set_other_info(const char* value) {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  other_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.login.other_info)
}
inline void login::set_other_info(const char* value, size_t size) {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  other_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.login.other_info)
}
inline ::std::string* login::mutable_other_info() {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.login.other_info)
  return other_info_;
}
inline ::std::string* login::release_other_info() {
  clear_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = other_info_;
    other_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_other_info(::std::string* other_info) {
  if (other_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete other_info_;
  }
  if (other_info) {
    set_has_other_info();
    other_info_ = other_info;
  } else {
    clear_has_other_info();
    other_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.login.other_info)
}

// -------------------------------------------------------------------

// login_result

// required .proto.login_result.login_result_code result = 1;
inline bool login_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::login_result_login_result_code login_result::result() const {
  // @@protoc_insertion_point(field_get:proto.login_result.result)
  return static_cast< ::proto::login_result_login_result_code >(result_);
}
inline void login_result::set_result(::proto::login_result_login_result_code value) {
  assert(::proto::login_result_login_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.login_result.result)
}

// -------------------------------------------------------------------

// user_register

// required string user_name = 1;
inline bool user_register::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_register::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_register::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_register::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& user_register::user_name() const {
  // @@protoc_insertion_point(field_get:proto.user_register.user_name)
  return *user_name_;
}
inline void user_register::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.user_name)
}
inline void user_register::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.user_name)
}
inline void user_register::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.user_name)
}
inline ::std::string* user_register::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.user_name)
  return user_name_;
}
inline ::std::string* user_register::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.user_name)
}

// required bytes rsa_pubkey = 2;
inline bool user_register::has_rsa_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_register::set_has_rsa_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_register::clear_has_rsa_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_register::clear_rsa_pubkey() {
  if (rsa_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_->clear();
  }
  clear_has_rsa_pubkey();
}
inline const ::std::string& user_register::rsa_pubkey() const {
  // @@protoc_insertion_point(field_get:proto.user_register.rsa_pubkey)
  return *rsa_pubkey_;
}
inline void user_register::set_rsa_pubkey(const ::std::string& value) {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  rsa_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.rsa_pubkey)
}
inline void user_register::set_rsa_pubkey(const char* value) {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  rsa_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.rsa_pubkey)
}
inline void user_register::set_rsa_pubkey(const void* value, size_t size) {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  rsa_pubkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.rsa_pubkey)
}
inline ::std::string* user_register::mutable_rsa_pubkey() {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.rsa_pubkey)
  return rsa_pubkey_;
}
inline ::std::string* user_register::release_rsa_pubkey() {
  clear_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rsa_pubkey_;
    rsa_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_rsa_pubkey(::std::string* rsa_pubkey) {
  if (rsa_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rsa_pubkey_;
  }
  if (rsa_pubkey) {
    set_has_rsa_pubkey();
    rsa_pubkey_ = rsa_pubkey;
  } else {
    clear_has_rsa_pubkey();
    rsa_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.rsa_pubkey)
}

// optional string mail_address = 3;
inline bool user_register::has_mail_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_register::set_has_mail_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_register::clear_has_mail_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_register::clear_mail_address() {
  if (mail_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_->clear();
  }
  clear_has_mail_address();
}
inline const ::std::string& user_register::mail_address() const {
  // @@protoc_insertion_point(field_get:proto.user_register.mail_address)
  return *mail_address_;
}
inline void user_register::set_mail_address(const ::std::string& value) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.mail_address)
}
inline void user_register::set_mail_address(const char* value) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.mail_address)
}
inline void user_register::set_mail_address(const char* value, size_t size) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.mail_address)
}
inline ::std::string* user_register::mutable_mail_address() {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.mail_address)
  return mail_address_;
}
inline ::std::string* user_register::release_mail_address() {
  clear_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mail_address_;
    mail_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_mail_address(::std::string* mail_address) {
  if (mail_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_address_;
  }
  if (mail_address) {
    set_has_mail_address();
    mail_address_ = mail_address;
  } else {
    clear_has_mail_address();
    mail_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.mail_address)
}

// optional string cell_phone = 4;
inline bool user_register::has_cell_phone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_register::set_has_cell_phone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_register::clear_has_cell_phone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_register::clear_cell_phone() {
  if (cell_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_->clear();
  }
  clear_has_cell_phone();
}
inline const ::std::string& user_register::cell_phone() const {
  // @@protoc_insertion_point(field_get:proto.user_register.cell_phone)
  return *cell_phone_;
}
inline void user_register::set_cell_phone(const ::std::string& value) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.cell_phone)
}
inline void user_register::set_cell_phone(const char* value) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.cell_phone)
}
inline void user_register::set_cell_phone(const char* value, size_t size) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.cell_phone)
}
inline ::std::string* user_register::mutable_cell_phone() {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.cell_phone)
  return cell_phone_;
}
inline ::std::string* user_register::release_cell_phone() {
  clear_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cell_phone_;
    cell_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_cell_phone(::std::string* cell_phone) {
  if (cell_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cell_phone_;
  }
  if (cell_phone) {
    set_has_cell_phone();
    cell_phone_ = cell_phone;
  } else {
    clear_has_cell_phone();
    cell_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.cell_phone)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::login_result_login_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::login_result_login_result_code>() {
  return ::proto::login_result_login_result_code_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
