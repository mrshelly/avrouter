// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef PROTOBUF_im_2eproto__INCLUDED
#define PROTOBUF_im_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_im_2eproto();
void protobuf_AssignDesc_im_2eproto();
void protobuf_ShutdownFile_im_2eproto();

class text_message;
class img_message;
class emoji_message;
class symmetry_encryption_key_distribution;
class avim_message;
class avim_message_packet;

enum symmetry_encryption_key_distribution_EncryptionType {
  symmetry_encryption_key_distribution_EncryptionType_AES = 0,
  symmetry_encryption_key_distribution_EncryptionType_DES = 1,
  symmetry_encryption_key_distribution_EncryptionType_BlowFish = 2,
  symmetry_encryption_key_distribution_EncryptionType_TwoFish = 3,
  symmetry_encryption_key_distribution_EncryptionType_Camellia = 4,
  symmetry_encryption_key_distribution_EncryptionType_DES3_EDE = 5
};
bool symmetry_encryption_key_distribution_EncryptionType_IsValid(int value);
const symmetry_encryption_key_distribution_EncryptionType symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MIN = symmetry_encryption_key_distribution_EncryptionType_AES;
const symmetry_encryption_key_distribution_EncryptionType symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MAX = symmetry_encryption_key_distribution_EncryptionType_DES3_EDE;
const int symmetry_encryption_key_distribution_EncryptionType_EncryptionType_ARRAYSIZE = symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* symmetry_encryption_key_distribution_EncryptionType_descriptor();
inline const ::std::string& symmetry_encryption_key_distribution_EncryptionType_Name(symmetry_encryption_key_distribution_EncryptionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    symmetry_encryption_key_distribution_EncryptionType_descriptor(), value);
}
inline bool symmetry_encryption_key_distribution_EncryptionType_Parse(
    const ::std::string& name, symmetry_encryption_key_distribution_EncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<symmetry_encryption_key_distribution_EncryptionType>(
    symmetry_encryption_key_distribution_EncryptionType_descriptor(), name, value);
}
// ===================================================================

class text_message : public ::google::protobuf::Message {
 public:
  text_message();
  virtual ~text_message();

  text_message(const text_message& from);

  inline text_message& operator=(const text_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline text_message& operator=(text_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  text_message(text_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const text_message& default_instance();

  void Swap(text_message* other);

  // implements Message ----------------------------------------------

  text_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const text_message& from);
  void MergeFrom(const text_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string fontname = 2;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontnameFieldNumber = 2;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional float fontsie = 3;
  inline bool has_fontsie() const;
  inline void clear_fontsie();
  static const int kFontsieFieldNumber = 3;
  inline float fontsie() const;
  inline void set_fontsie(float value);

  // optional string hlink = 4;
  inline bool has_hlink() const;
  inline void clear_hlink();
  static const int kHlinkFieldNumber = 4;
  inline const ::std::string& hlink() const;
  inline void set_hlink(const ::std::string& value);
  inline void set_hlink(const char* value);
  inline void set_hlink(const char* value, size_t size);
  inline ::std::string* mutable_hlink();
  inline ::std::string* release_hlink();
  inline void set_allocated_hlink(::std::string* hlink);

  // @@protoc_insertion_point(class_scope:proto.text_message)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontsie();
  inline void clear_has_fontsie();
  inline void set_has_hlink();
  inline void clear_has_hlink();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::std::string* fontname_;
  ::std::string* hlink_;
  float fontsie_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static text_message* default_instance_;
};
// -------------------------------------------------------------------

class img_message : public ::google::protobuf::Message {
 public:
  img_message();
  virtual ~img_message();

  img_message(const img_message& from);

  inline img_message& operator=(const img_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline img_message& operator=(img_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  img_message(img_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const img_message& default_instance();

  void Swap(img_message* other);

  // implements Message ----------------------------------------------

  img_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const img_message& from);
  void MergeFrom(const img_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const void* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional bytes image_digest = 2;
  inline bool has_image_digest() const;
  inline void clear_image_digest();
  static const int kImageDigestFieldNumber = 2;
  inline const ::std::string& image_digest() const;
  inline void set_image_digest(const ::std::string& value);
  inline void set_image_digest(const char* value);
  inline void set_image_digest(const void* value, size_t size);
  inline ::std::string* mutable_image_digest();
  inline ::std::string* release_image_digest();
  inline void set_allocated_image_digest(::std::string* image_digest);

  // optional string hlink = 4;
  inline bool has_hlink() const;
  inline void clear_hlink();
  static const int kHlinkFieldNumber = 4;
  inline const ::std::string& hlink() const;
  inline void set_hlink(const ::std::string& value);
  inline void set_hlink(const char* value);
  inline void set_hlink(const char* value, size_t size);
  inline ::std::string* mutable_hlink();
  inline ::std::string* release_hlink();
  inline void set_allocated_hlink(::std::string* hlink);

  // @@protoc_insertion_point(class_scope:proto.img_message)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_digest();
  inline void clear_has_image_digest();
  inline void set_has_hlink();
  inline void clear_has_hlink();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* image_;
  ::std::string* image_digest_;
  ::std::string* hlink_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static img_message* default_instance_;
};
// -------------------------------------------------------------------

class emoji_message : public ::google::protobuf::Message {
 public:
  emoji_message();
  virtual ~emoji_message();

  emoji_message(const emoji_message& from);

  inline emoji_message& operator=(const emoji_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline emoji_message& operator=(emoji_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  emoji_message(emoji_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emoji_message& default_instance();

  void Swap(emoji_message* other);

  // implements Message ----------------------------------------------

  emoji_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emoji_message& from);
  void MergeFrom(const emoji_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string emoji = 1;
  inline bool has_emoji() const;
  inline void clear_emoji();
  static const int kEmojiFieldNumber = 1;
  inline const ::std::string& emoji() const;
  inline void set_emoji(const ::std::string& value);
  inline void set_emoji(const char* value);
  inline void set_emoji(const char* value, size_t size);
  inline ::std::string* mutable_emoji();
  inline ::std::string* release_emoji();
  inline void set_allocated_emoji(::std::string* emoji);

  // optional string theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::std::string& theme() const;
  inline void set_theme(const ::std::string& value);
  inline void set_theme(const char* value);
  inline void set_theme(const char* value, size_t size);
  inline ::std::string* mutable_theme();
  inline ::std::string* release_theme();
  inline void set_allocated_theme(::std::string* theme);

  // optional bytes custom_image = 3;
  inline bool has_custom_image() const;
  inline void clear_custom_image();
  static const int kCustomImageFieldNumber = 3;
  inline const ::std::string& custom_image() const;
  inline void set_custom_image(const ::std::string& value);
  inline void set_custom_image(const char* value);
  inline void set_custom_image(const void* value, size_t size);
  inline ::std::string* mutable_custom_image();
  inline ::std::string* release_custom_image();
  inline void set_allocated_custom_image(::std::string* custom_image);

  // @@protoc_insertion_point(class_scope:proto.emoji_message)
 private:
  inline void set_has_emoji();
  inline void clear_has_emoji();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_custom_image();
  inline void clear_has_custom_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* emoji_;
  ::std::string* theme_;
  ::std::string* custom_image_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static emoji_message* default_instance_;
};
// -------------------------------------------------------------------

class symmetry_encryption_key_distribution : public ::google::protobuf::Message {
 public:
  symmetry_encryption_key_distribution();
  virtual ~symmetry_encryption_key_distribution();

  symmetry_encryption_key_distribution(const symmetry_encryption_key_distribution& from);

  inline symmetry_encryption_key_distribution& operator=(const symmetry_encryption_key_distribution& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline symmetry_encryption_key_distribution& operator=(symmetry_encryption_key_distribution&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  symmetry_encryption_key_distribution(symmetry_encryption_key_distribution&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const symmetry_encryption_key_distribution& default_instance();

  void Swap(symmetry_encryption_key_distribution* other);

  // implements Message ----------------------------------------------

  symmetry_encryption_key_distribution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const symmetry_encryption_key_distribution& from);
  void MergeFrom(const symmetry_encryption_key_distribution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef symmetry_encryption_key_distribution_EncryptionType EncryptionType;
  static const EncryptionType AES = symmetry_encryption_key_distribution_EncryptionType_AES;
  static const EncryptionType DES = symmetry_encryption_key_distribution_EncryptionType_DES;
  static const EncryptionType BlowFish = symmetry_encryption_key_distribution_EncryptionType_BlowFish;
  static const EncryptionType TwoFish = symmetry_encryption_key_distribution_EncryptionType_TwoFish;
  static const EncryptionType Camellia = symmetry_encryption_key_distribution_EncryptionType_Camellia;
  static const EncryptionType DES3_EDE = symmetry_encryption_key_distribution_EncryptionType_DES3_EDE;
  static inline bool EncryptionType_IsValid(int value) {
    return symmetry_encryption_key_distribution_EncryptionType_IsValid(value);
  }
  static const EncryptionType EncryptionType_MIN =
    symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MIN;
  static const EncryptionType EncryptionType_MAX =
    symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MAX;
  static const int EncryptionType_ARRAYSIZE =
    symmetry_encryption_key_distribution_EncryptionType_EncryptionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EncryptionType_descriptor() {
    return symmetry_encryption_key_distribution_EncryptionType_descriptor();
  }
  static inline const ::std::string& EncryptionType_Name(EncryptionType value) {
    return symmetry_encryption_key_distribution_EncryptionType_Name(value);
  }
  static inline bool EncryptionType_Parse(const ::std::string& name,
      EncryptionType* value) {
    return symmetry_encryption_key_distribution_EncryptionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.symmetry_encryption_key_distribution.EncryptionType keytype = 1;
  inline bool has_keytype() const;
  inline void clear_keytype();
  static const int kKeytypeFieldNumber = 1;
  inline ::proto::symmetry_encryption_key_distribution_EncryptionType keytype() const;
  inline void set_keytype(::proto::symmetry_encryption_key_distribution_EncryptionType value);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:proto.symmetry_encryption_key_distribution)
 private:
  inline void set_has_keytype();
  inline void clear_has_keytype();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  int keytype_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static symmetry_encryption_key_distribution* default_instance_;
};
// -------------------------------------------------------------------

class avim_message : public ::google::protobuf::Message {
 public:
  avim_message();
  virtual ~avim_message();

  avim_message(const avim_message& from);

  inline avim_message& operator=(const avim_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline avim_message& operator=(avim_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  avim_message(avim_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avim_message& default_instance();

  void Swap(avim_message* other);

  // implements Message ----------------------------------------------

  avim_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avim_message& from);
  void MergeFrom(const avim_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.text_message item_text = 1;
  inline bool has_item_text() const;
  inline void clear_item_text();
  static const int kItemTextFieldNumber = 1;
  inline const ::proto::text_message& item_text() const;
  inline ::proto::text_message* mutable_item_text();
  inline ::proto::text_message* release_item_text();
  inline void set_allocated_item_text(::proto::text_message* item_text);

  // optional .proto.img_message item_image = 2;
  inline bool has_item_image() const;
  inline void clear_item_image();
  static const int kItemImageFieldNumber = 2;
  inline const ::proto::img_message& item_image() const;
  inline ::proto::img_message* mutable_item_image();
  inline ::proto::img_message* release_item_image();
  inline void set_allocated_item_image(::proto::img_message* item_image);

  // optional .proto.emoji_message item_emoji = 3;
  inline bool has_item_emoji() const;
  inline void clear_item_emoji();
  static const int kItemEmojiFieldNumber = 3;
  inline const ::proto::emoji_message& item_emoji() const;
  inline ::proto::emoji_message* mutable_item_emoji();
  inline ::proto::emoji_message* release_item_emoji();
  inline void set_allocated_item_emoji(::proto::emoji_message* item_emoji);

  // optional .proto.symmetry_encryption_key_distribution item_key = 20;
  inline bool has_item_key() const;
  inline void clear_item_key();
  static const int kItemKeyFieldNumber = 20;
  inline const ::proto::symmetry_encryption_key_distribution& item_key() const;
  inline ::proto::symmetry_encryption_key_distribution* mutable_item_key();
  inline ::proto::symmetry_encryption_key_distribution* release_item_key();
  inline void set_allocated_item_key(::proto::symmetry_encryption_key_distribution* item_key);

  // @@protoc_insertion_point(class_scope:proto.avim_message)
 private:
  inline void set_has_item_text();
  inline void clear_has_item_text();
  inline void set_has_item_image();
  inline void clear_has_item_image();
  inline void set_has_item_emoji();
  inline void clear_has_item_emoji();
  inline void set_has_item_key();
  inline void clear_has_item_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::text_message* item_text_;
  ::proto::img_message* item_image_;
  ::proto::emoji_message* item_emoji_;
  ::proto::symmetry_encryption_key_distribution* item_key_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static avim_message* default_instance_;
};
// -------------------------------------------------------------------

class avim_message_packet : public ::google::protobuf::Message {
 public:
  avim_message_packet();
  virtual ~avim_message_packet();

  avim_message_packet(const avim_message_packet& from);

  inline avim_message_packet& operator=(const avim_message_packet& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline avim_message_packet& operator=(avim_message_packet&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  avim_message_packet(avim_message_packet&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avim_message_packet& default_instance();

  void Swap(avim_message_packet* other);

  // implements Message ----------------------------------------------

  avim_message_packet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avim_message_packet& from);
  void MergeFrom(const avim_message_packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.avim_message avim = 1;
  inline int avim_size() const;
  inline void clear_avim();
  static const int kAvimFieldNumber = 1;
  inline const ::proto::avim_message& avim(int index) const;
  inline ::proto::avim_message* mutable_avim(int index);
  inline ::proto::avim_message* add_avim();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::avim_message >&
      avim() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::avim_message >*
      mutable_avim();

  // optional uint64 serial = 2;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 2;
  inline ::google::protobuf::uint64 serial() const;
  inline void set_serial(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.avim_message_packet)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::avim_message > avim_;
  ::google::protobuf::uint64 serial_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static avim_message_packet* default_instance_;
};
// ===================================================================


// ===================================================================

// text_message

// required string text = 1;
inline bool text_message::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void text_message::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void text_message::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void text_message::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& text_message::text() const {
  // @@protoc_insertion_point(field_get:proto.text_message.text)
  return *text_;
}
inline void text_message::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:proto.text_message.text)
}
inline void text_message::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.text_message.text)
}
inline void text_message::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.text_message.text)
}
inline ::std::string* text_message::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.text_message.text)
  return text_;
}
inline ::std::string* text_message::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void text_message::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.text_message.text)
}

// optional string fontname = 2;
inline bool text_message::has_fontname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void text_message::set_has_fontname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void text_message::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void text_message::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& text_message::fontname() const {
  // @@protoc_insertion_point(field_get:proto.text_message.fontname)
  return *fontname_;
}
inline void text_message::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set:proto.text_message.fontname)
}
inline void text_message::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.text_message.fontname)
}
inline void text_message::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.text_message.fontname)
}
inline ::std::string* text_message::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.text_message.fontname)
  return fontname_;
}
inline ::std::string* text_message::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void text_message::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.text_message.fontname)
}

// optional float fontsie = 3;
inline bool text_message::has_fontsie() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void text_message::set_has_fontsie() {
  _has_bits_[0] |= 0x00000004u;
}
inline void text_message::clear_has_fontsie() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void text_message::clear_fontsie() {
  fontsie_ = 0;
  clear_has_fontsie();
}
inline float text_message::fontsie() const {
  // @@protoc_insertion_point(field_get:proto.text_message.fontsie)
  return fontsie_;
}
inline void text_message::set_fontsie(float value) {
  set_has_fontsie();
  fontsie_ = value;
  // @@protoc_insertion_point(field_set:proto.text_message.fontsie)
}

// optional string hlink = 4;
inline bool text_message::has_hlink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void text_message::set_has_hlink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void text_message::clear_has_hlink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void text_message::clear_hlink() {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_->clear();
  }
  clear_has_hlink();
}
inline const ::std::string& text_message::hlink() const {
  // @@protoc_insertion_point(field_get:proto.text_message.hlink)
  return *hlink_;
}
inline void text_message::set_hlink(const ::std::string& value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set:proto.text_message.hlink)
}
inline void text_message::set_hlink(const char* value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.text_message.hlink)
}
inline void text_message::set_hlink(const char* value, size_t size) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.text_message.hlink)
}
inline ::std::string* text_message::mutable_hlink() {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.text_message.hlink)
  return hlink_;
}
inline ::std::string* text_message::release_hlink() {
  clear_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hlink_;
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void text_message::set_allocated_hlink(::std::string* hlink) {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hlink_;
  }
  if (hlink) {
    set_has_hlink();
    hlink_ = hlink;
  } else {
    clear_has_hlink();
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.text_message.hlink)
}

// -------------------------------------------------------------------

// img_message

// required bytes image = 1;
inline bool img_message::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void img_message::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void img_message::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void img_message::clear_image() {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& img_message::image() const {
  // @@protoc_insertion_point(field_get:proto.img_message.image)
  return *image_;
}
inline void img_message::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set:proto.img_message.image)
}
inline void img_message::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.img_message.image)
}
inline void img_message::set_image(const void* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.img_message.image)
}
inline ::std::string* img_message::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.img_message.image)
  return image_;
}
inline ::std::string* img_message::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void img_message::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.img_message.image)
}

// optional bytes image_digest = 2;
inline bool img_message::has_image_digest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void img_message::set_has_image_digest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void img_message::clear_has_image_digest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void img_message::clear_image_digest() {
  if (image_digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_->clear();
  }
  clear_has_image_digest();
}
inline const ::std::string& img_message::image_digest() const {
  // @@protoc_insertion_point(field_get:proto.img_message.image_digest)
  return *image_digest_;
}
inline void img_message::set_image_digest(const ::std::string& value) {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  image_digest_->assign(value);
  // @@protoc_insertion_point(field_set:proto.img_message.image_digest)
}
inline void img_message::set_image_digest(const char* value) {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  image_digest_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.img_message.image_digest)
}
inline void img_message::set_image_digest(const void* value, size_t size) {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  image_digest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.img_message.image_digest)
}
inline ::std::string* img_message::mutable_image_digest() {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.img_message.image_digest)
  return image_digest_;
}
inline ::std::string* img_message::release_image_digest() {
  clear_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_digest_;
    image_digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void img_message::set_allocated_image_digest(::std::string* image_digest) {
  if (image_digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_digest_;
  }
  if (image_digest) {
    set_has_image_digest();
    image_digest_ = image_digest;
  } else {
    clear_has_image_digest();
    image_digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.img_message.image_digest)
}

// optional string hlink = 4;
inline bool img_message::has_hlink() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void img_message::set_has_hlink() {
  _has_bits_[0] |= 0x00000004u;
}
inline void img_message::clear_has_hlink() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void img_message::clear_hlink() {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_->clear();
  }
  clear_has_hlink();
}
inline const ::std::string& img_message::hlink() const {
  // @@protoc_insertion_point(field_get:proto.img_message.hlink)
  return *hlink_;
}
inline void img_message::set_hlink(const ::std::string& value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set:proto.img_message.hlink)
}
inline void img_message::set_hlink(const char* value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.img_message.hlink)
}
inline void img_message::set_hlink(const char* value, size_t size) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.img_message.hlink)
}
inline ::std::string* img_message::mutable_hlink() {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.img_message.hlink)
  return hlink_;
}
inline ::std::string* img_message::release_hlink() {
  clear_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hlink_;
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void img_message::set_allocated_hlink(::std::string* hlink) {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hlink_;
  }
  if (hlink) {
    set_has_hlink();
    hlink_ = hlink;
  } else {
    clear_has_hlink();
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.img_message.hlink)
}

// -------------------------------------------------------------------

// emoji_message

// required string emoji = 1;
inline bool emoji_message::has_emoji() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emoji_message::set_has_emoji() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emoji_message::clear_has_emoji() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emoji_message::clear_emoji() {
  if (emoji_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_->clear();
  }
  clear_has_emoji();
}
inline const ::std::string& emoji_message::emoji() const {
  // @@protoc_insertion_point(field_get:proto.emoji_message.emoji)
  return *emoji_;
}
inline void emoji_message::set_emoji(const ::std::string& value) {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  emoji_->assign(value);
  // @@protoc_insertion_point(field_set:proto.emoji_message.emoji)
}
inline void emoji_message::set_emoji(const char* value) {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  emoji_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.emoji_message.emoji)
}
inline void emoji_message::set_emoji(const char* value, size_t size) {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  emoji_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.emoji_message.emoji)
}
inline ::std::string* emoji_message::mutable_emoji() {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.emoji_message.emoji)
  return emoji_;
}
inline ::std::string* emoji_message::release_emoji() {
  clear_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = emoji_;
    emoji_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void emoji_message::set_allocated_emoji(::std::string* emoji) {
  if (emoji_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete emoji_;
  }
  if (emoji) {
    set_has_emoji();
    emoji_ = emoji;
  } else {
    clear_has_emoji();
    emoji_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.emoji_message.emoji)
}

// optional string theme = 2;
inline bool emoji_message::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void emoji_message::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void emoji_message::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void emoji_message::clear_theme() {
  if (theme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_->clear();
  }
  clear_has_theme();
}
inline const ::std::string& emoji_message::theme() const {
  // @@protoc_insertion_point(field_get:proto.emoji_message.theme)
  return *theme_;
}
inline void emoji_message::set_theme(const ::std::string& value) {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  theme_->assign(value);
  // @@protoc_insertion_point(field_set:proto.emoji_message.theme)
}
inline void emoji_message::set_theme(const char* value) {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  theme_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.emoji_message.theme)
}
inline void emoji_message::set_theme(const char* value, size_t size) {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  theme_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.emoji_message.theme)
}
inline ::std::string* emoji_message::mutable_theme() {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.emoji_message.theme)
  return theme_;
}
inline ::std::string* emoji_message::release_theme() {
  clear_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = theme_;
    theme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void emoji_message::set_allocated_theme(::std::string* theme) {
  if (theme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete theme_;
  }
  if (theme) {
    set_has_theme();
    theme_ = theme;
  } else {
    clear_has_theme();
    theme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.emoji_message.theme)
}

// optional bytes custom_image = 3;
inline bool emoji_message::has_custom_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void emoji_message::set_has_custom_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void emoji_message::clear_has_custom_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void emoji_message::clear_custom_image() {
  if (custom_image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_->clear();
  }
  clear_has_custom_image();
}
inline const ::std::string& emoji_message::custom_image() const {
  // @@protoc_insertion_point(field_get:proto.emoji_message.custom_image)
  return *custom_image_;
}
inline void emoji_message::set_custom_image(const ::std::string& value) {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  custom_image_->assign(value);
  // @@protoc_insertion_point(field_set:proto.emoji_message.custom_image)
}
inline void emoji_message::set_custom_image(const char* value) {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  custom_image_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.emoji_message.custom_image)
}
inline void emoji_message::set_custom_image(const void* value, size_t size) {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  custom_image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.emoji_message.custom_image)
}
inline ::std::string* emoji_message::mutable_custom_image() {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.emoji_message.custom_image)
  return custom_image_;
}
inline ::std::string* emoji_message::release_custom_image() {
  clear_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = custom_image_;
    custom_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void emoji_message::set_allocated_custom_image(::std::string* custom_image) {
  if (custom_image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete custom_image_;
  }
  if (custom_image) {
    set_has_custom_image();
    custom_image_ = custom_image;
  } else {
    clear_has_custom_image();
    custom_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.emoji_message.custom_image)
}

// -------------------------------------------------------------------

// symmetry_encryption_key_distribution

// required .proto.symmetry_encryption_key_distribution.EncryptionType keytype = 1;
inline bool symmetry_encryption_key_distribution::has_keytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void symmetry_encryption_key_distribution::set_has_keytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void symmetry_encryption_key_distribution::clear_has_keytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void symmetry_encryption_key_distribution::clear_keytype() {
  keytype_ = 0;
  clear_has_keytype();
}
inline ::proto::symmetry_encryption_key_distribution_EncryptionType symmetry_encryption_key_distribution::keytype() const {
  // @@protoc_insertion_point(field_get:proto.symmetry_encryption_key_distribution.keytype)
  return static_cast< ::proto::symmetry_encryption_key_distribution_EncryptionType >(keytype_);
}
inline void symmetry_encryption_key_distribution::set_keytype(::proto::symmetry_encryption_key_distribution_EncryptionType value) {
  assert(::proto::symmetry_encryption_key_distribution_EncryptionType_IsValid(value));
  set_has_keytype();
  keytype_ = value;
  // @@protoc_insertion_point(field_set:proto.symmetry_encryption_key_distribution.keytype)
}

// required bytes key = 2;
inline bool symmetry_encryption_key_distribution::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void symmetry_encryption_key_distribution::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void symmetry_encryption_key_distribution::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void symmetry_encryption_key_distribution::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& symmetry_encryption_key_distribution::key() const {
  // @@protoc_insertion_point(field_get:proto.symmetry_encryption_key_distribution.key)
  return *key_;
}
inline void symmetry_encryption_key_distribution::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.symmetry_encryption_key_distribution.key)
}
inline void symmetry_encryption_key_distribution::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.symmetry_encryption_key_distribution.key)
}
inline void symmetry_encryption_key_distribution::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.symmetry_encryption_key_distribution.key)
}
inline ::std::string* symmetry_encryption_key_distribution::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.symmetry_encryption_key_distribution.key)
  return key_;
}
inline ::std::string* symmetry_encryption_key_distribution::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void symmetry_encryption_key_distribution::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.symmetry_encryption_key_distribution.key)
}

// -------------------------------------------------------------------

// avim_message

// optional .proto.text_message item_text = 1;
inline bool avim_message::has_item_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avim_message::set_has_item_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avim_message::clear_has_item_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avim_message::clear_item_text() {
  if (item_text_ != NULL) item_text_->::proto::text_message::Clear();
  clear_has_item_text();
}
inline const ::proto::text_message& avim_message::item_text() const {
  // @@protoc_insertion_point(field_get:proto.avim_message.item_text)
  return item_text_ != NULL ? *item_text_ : *default_instance_->item_text_;
}
inline ::proto::text_message* avim_message::mutable_item_text() {
  set_has_item_text();
  if (item_text_ == NULL) item_text_ = new ::proto::text_message;
  // @@protoc_insertion_point(field_mutable:proto.avim_message.item_text)
  return item_text_;
}
inline ::proto::text_message* avim_message::release_item_text() {
  clear_has_item_text();
  ::proto::text_message* temp = item_text_;
  item_text_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_text(::proto::text_message* item_text) {
  delete item_text_;
  item_text_ = item_text;
  if (item_text) {
    set_has_item_text();
  } else {
    clear_has_item_text();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.avim_message.item_text)
}

// optional .proto.img_message item_image = 2;
inline bool avim_message::has_item_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avim_message::set_has_item_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avim_message::clear_has_item_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avim_message::clear_item_image() {
  if (item_image_ != NULL) item_image_->::proto::img_message::Clear();
  clear_has_item_image();
}
inline const ::proto::img_message& avim_message::item_image() const {
  // @@protoc_insertion_point(field_get:proto.avim_message.item_image)
  return item_image_ != NULL ? *item_image_ : *default_instance_->item_image_;
}
inline ::proto::img_message* avim_message::mutable_item_image() {
  set_has_item_image();
  if (item_image_ == NULL) item_image_ = new ::proto::img_message;
  // @@protoc_insertion_point(field_mutable:proto.avim_message.item_image)
  return item_image_;
}
inline ::proto::img_message* avim_message::release_item_image() {
  clear_has_item_image();
  ::proto::img_message* temp = item_image_;
  item_image_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_image(::proto::img_message* item_image) {
  delete item_image_;
  item_image_ = item_image;
  if (item_image) {
    set_has_item_image();
  } else {
    clear_has_item_image();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.avim_message.item_image)
}

// optional .proto.emoji_message item_emoji = 3;
inline bool avim_message::has_item_emoji() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void avim_message::set_has_item_emoji() {
  _has_bits_[0] |= 0x00000004u;
}
inline void avim_message::clear_has_item_emoji() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void avim_message::clear_item_emoji() {
  if (item_emoji_ != NULL) item_emoji_->::proto::emoji_message::Clear();
  clear_has_item_emoji();
}
inline const ::proto::emoji_message& avim_message::item_emoji() const {
  // @@protoc_insertion_point(field_get:proto.avim_message.item_emoji)
  return item_emoji_ != NULL ? *item_emoji_ : *default_instance_->item_emoji_;
}
inline ::proto::emoji_message* avim_message::mutable_item_emoji() {
  set_has_item_emoji();
  if (item_emoji_ == NULL) item_emoji_ = new ::proto::emoji_message;
  // @@protoc_insertion_point(field_mutable:proto.avim_message.item_emoji)
  return item_emoji_;
}
inline ::proto::emoji_message* avim_message::release_item_emoji() {
  clear_has_item_emoji();
  ::proto::emoji_message* temp = item_emoji_;
  item_emoji_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_emoji(::proto::emoji_message* item_emoji) {
  delete item_emoji_;
  item_emoji_ = item_emoji;
  if (item_emoji) {
    set_has_item_emoji();
  } else {
    clear_has_item_emoji();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.avim_message.item_emoji)
}

// optional .proto.symmetry_encryption_key_distribution item_key = 20;
inline bool avim_message::has_item_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void avim_message::set_has_item_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void avim_message::clear_has_item_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void avim_message::clear_item_key() {
  if (item_key_ != NULL) item_key_->::proto::symmetry_encryption_key_distribution::Clear();
  clear_has_item_key();
}
inline const ::proto::symmetry_encryption_key_distribution& avim_message::item_key() const {
  // @@protoc_insertion_point(field_get:proto.avim_message.item_key)
  return item_key_ != NULL ? *item_key_ : *default_instance_->item_key_;
}
inline ::proto::symmetry_encryption_key_distribution* avim_message::mutable_item_key() {
  set_has_item_key();
  if (item_key_ == NULL) item_key_ = new ::proto::symmetry_encryption_key_distribution;
  // @@protoc_insertion_point(field_mutable:proto.avim_message.item_key)
  return item_key_;
}
inline ::proto::symmetry_encryption_key_distribution* avim_message::release_item_key() {
  clear_has_item_key();
  ::proto::symmetry_encryption_key_distribution* temp = item_key_;
  item_key_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_key(::proto::symmetry_encryption_key_distribution* item_key) {
  delete item_key_;
  item_key_ = item_key;
  if (item_key) {
    set_has_item_key();
  } else {
    clear_has_item_key();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.avim_message.item_key)
}

// -------------------------------------------------------------------

// avim_message_packet

// repeated .proto.avim_message avim = 1;
inline int avim_message_packet::avim_size() const {
  return avim_.size();
}
inline void avim_message_packet::clear_avim() {
  avim_.Clear();
}
inline const ::proto::avim_message& avim_message_packet::avim(int index) const {
  // @@protoc_insertion_point(field_get:proto.avim_message_packet.avim)
  return avim_.Get(index);
}
inline ::proto::avim_message* avim_message_packet::mutable_avim(int index) {
  // @@protoc_insertion_point(field_mutable:proto.avim_message_packet.avim)
  return avim_.Mutable(index);
}
inline ::proto::avim_message* avim_message_packet::add_avim() {
  // @@protoc_insertion_point(field_add:proto.avim_message_packet.avim)
  return avim_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::avim_message >&
avim_message_packet::avim() const {
  // @@protoc_insertion_point(field_list:proto.avim_message_packet.avim)
  return avim_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::avim_message >*
avim_message_packet::mutable_avim() {
  // @@protoc_insertion_point(field_mutable_list:proto.avim_message_packet.avim)
  return &avim_;
}

// optional uint64 serial = 2;
inline bool avim_message_packet::has_serial() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avim_message_packet::set_has_serial() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avim_message_packet::clear_has_serial() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avim_message_packet::clear_serial() {
  serial_ = GOOGLE_ULONGLONG(0);
  clear_has_serial();
}
inline ::google::protobuf::uint64 avim_message_packet::serial() const {
  // @@protoc_insertion_point(field_get:proto.avim_message_packet.serial)
  return serial_;
}
inline void avim_message_packet::set_serial(::google::protobuf::uint64 value) {
  set_has_serial();
  serial_ = value;
  // @@protoc_insertion_point(field_set:proto.avim_message_packet.serial)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::symmetry_encryption_key_distribution_EncryptionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::symmetry_encryption_key_distribution_EncryptionType>() {
  return ::proto::symmetry_encryption_key_distribution_EncryptionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_im_2eproto__INCLUDED
