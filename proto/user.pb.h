// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class client_hello;
class server_hello;
class login;
class login_result;
class username_availability_check;
class username_availability_result;
class user_register;
class user_register_result;
class user_cert_lost_request;
class user_cert_lost_verify;

enum login_result_login_result_code {
  login_result_login_result_code_LOGIN_SUCCEED = 0,
  login_result_login_result_code_NO_SUCH_USER = 1,
  login_result_login_result_code_PEREMISSON_DENIED = 2,
  login_result_login_result_code_PUBLIC_KEY_MISMATCH = 3
};
bool login_result_login_result_code_IsValid(int value);
const login_result_login_result_code login_result_login_result_code_login_result_code_MIN = login_result_login_result_code_LOGIN_SUCCEED;
const login_result_login_result_code login_result_login_result_code_login_result_code_MAX = login_result_login_result_code_PUBLIC_KEY_MISMATCH;
const int login_result_login_result_code_login_result_code_ARRAYSIZE = login_result_login_result_code_login_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* login_result_login_result_code_descriptor();
inline const ::std::string& login_result_login_result_code_Name(login_result_login_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    login_result_login_result_code_descriptor(), value);
}
inline bool login_result_login_result_code_Parse(
    const ::std::string& name, login_result_login_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<login_result_login_result_code>(
    login_result_login_result_code_descriptor(), name, value);
}
enum username_availability_result_username_availability_result_code {
  username_availability_result_username_availability_result_code_NAME_AVAILABLE = 0,
  username_availability_result_username_availability_result_code_NAME_DISALLOW = 1,
  username_availability_result_username_availability_result_code_NAME_TAKEN = 2
};
bool username_availability_result_username_availability_result_code_IsValid(int value);
const username_availability_result_username_availability_result_code username_availability_result_username_availability_result_code_username_availability_result_code_MIN = username_availability_result_username_availability_result_code_NAME_AVAILABLE;
const username_availability_result_username_availability_result_code username_availability_result_username_availability_result_code_username_availability_result_code_MAX = username_availability_result_username_availability_result_code_NAME_TAKEN;
const int username_availability_result_username_availability_result_code_username_availability_result_code_ARRAYSIZE = username_availability_result_username_availability_result_code_username_availability_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* username_availability_result_username_availability_result_code_descriptor();
inline const ::std::string& username_availability_result_username_availability_result_code_Name(username_availability_result_username_availability_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    username_availability_result_username_availability_result_code_descriptor(), value);
}
inline bool username_availability_result_username_availability_result_code_Parse(
    const ::std::string& name, username_availability_result_username_availability_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<username_availability_result_username_availability_result_code>(
    username_availability_result_username_availability_result_code_descriptor(), name, value);
}
enum user_register_result_user_register_result_code {
  user_register_result_user_register_result_code_REGISTER_SUCCEED = 0,
  user_register_result_user_register_result_code_REGISTER_SUCCEED_PENDDING_CERT = 1,
  user_register_result_user_register_result_code_REGISTER_FAILED_NAME_TAKEN = 2,
  user_register_result_user_register_result_code_REGISTER_FAILED_TOO_SHORT_KEY = 3,
  user_register_result_user_register_result_code_REGISTER_FAILED_NAME_DISALLOW = 4,
  user_register_result_user_register_result_code_REGISTER_FAILED_CA_DOWN = 5,
  user_register_result_user_register_result_code_REGISTER_FAILED_CSR_VERIFY_FAILURE = 6
};
bool user_register_result_user_register_result_code_IsValid(int value);
const user_register_result_user_register_result_code user_register_result_user_register_result_code_user_register_result_code_MIN = user_register_result_user_register_result_code_REGISTER_SUCCEED;
const user_register_result_user_register_result_code user_register_result_user_register_result_code_user_register_result_code_MAX = user_register_result_user_register_result_code_REGISTER_FAILED_CSR_VERIFY_FAILURE;
const int user_register_result_user_register_result_code_user_register_result_code_ARRAYSIZE = user_register_result_user_register_result_code_user_register_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* user_register_result_user_register_result_code_descriptor();
inline const ::std::string& user_register_result_user_register_result_code_Name(user_register_result_user_register_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    user_register_result_user_register_result_code_descriptor(), value);
}
inline bool user_register_result_user_register_result_code_Parse(
    const ::std::string& name, user_register_result_user_register_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<user_register_result_user_register_result_code>(
    user_register_result_user_register_result_code_descriptor(), name, value);
}
// ===================================================================

class client_hello : public ::google::protobuf::Message {
 public:
  client_hello();
  virtual ~client_hello();

  client_hello(const client_hello& from);

  inline client_hello& operator=(const client_hello& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline client_hello& operator=(client_hello&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  client_hello(client_hello&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_hello& default_instance();

  void Swap(client_hello* other);

  // implements Message ----------------------------------------------

  client_hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_hello& from);
  void MergeFrom(const client_hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::std::string& client() const;
  inline void set_client(const ::std::string& value);
  inline void set_client(const char* value);
  inline void set_client(const char* value, size_t size);
  inline ::std::string* mutable_client();
  inline ::std::string* release_client();
  inline void set_allocated_client(::std::string* client);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bytes random_g = 3;
  inline bool has_random_g() const;
  inline void clear_random_g();
  static const int kRandomGFieldNumber = 3;
  inline const ::std::string& random_g() const;
  inline void set_random_g(const ::std::string& value);
  inline void set_random_g(const char* value);
  inline void set_random_g(const void* value, size_t size);
  inline ::std::string* mutable_random_g();
  inline ::std::string* release_random_g();
  inline void set_allocated_random_g(::std::string* random_g);

  // required bytes random_p = 4;
  inline bool has_random_p() const;
  inline void clear_random_p();
  static const int kRandomPFieldNumber = 4;
  inline const ::std::string& random_p() const;
  inline void set_random_p(const ::std::string& value);
  inline void set_random_p(const char* value);
  inline void set_random_p(const void* value, size_t size);
  inline ::std::string* mutable_random_p();
  inline ::std::string* release_random_p();
  inline void set_allocated_random_p(::std::string* random_p);

  // required bytes random_pub_key = 5;
  inline bool has_random_pub_key() const;
  inline void clear_random_pub_key();
  static const int kRandomPubKeyFieldNumber = 5;
  inline const ::std::string& random_pub_key() const;
  inline void set_random_pub_key(const ::std::string& value);
  inline void set_random_pub_key(const char* value);
  inline void set_random_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_random_pub_key();
  inline ::std::string* release_random_pub_key();
  inline void set_allocated_random_pub_key(::std::string* random_pub_key);

  // @@protoc_insertion_point(class_scope:proto.client_hello)
 private:
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_g();
  inline void clear_has_random_g();
  inline void set_has_random_p();
  inline void clear_has_random_p();
  inline void set_has_random_pub_key();
  inline void clear_has_random_pub_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_;
  ::std::string* random_g_;
  ::std::string* random_p_;
  ::std::string* random_pub_key_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static client_hello* default_instance_;
};
// -------------------------------------------------------------------

class server_hello : public ::google::protobuf::Message {
 public:
  server_hello();
  virtual ~server_hello();

  server_hello(const server_hello& from);

  inline server_hello& operator=(const server_hello& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline server_hello& operator=(server_hello&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  server_hello(server_hello&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const server_hello& default_instance();

  void Swap(server_hello* other);

  // implements Message ----------------------------------------------

  server_hello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const server_hello& from);
  void MergeFrom(const server_hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string servername = 1;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 1;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bytes random_pub_key = 3;
  inline bool has_random_pub_key() const;
  inline void clear_random_pub_key();
  static const int kRandomPubKeyFieldNumber = 3;
  inline const ::std::string& random_pub_key() const;
  inline void set_random_pub_key(const ::std::string& value);
  inline void set_random_pub_key(const char* value);
  inline void set_random_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_random_pub_key();
  inline ::std::string* release_random_pub_key();
  inline void set_allocated_random_pub_key(::std::string* random_pub_key);

  // required string server_av_address = 4;
  inline bool has_server_av_address() const;
  inline void clear_server_av_address();
  static const int kServerAvAddressFieldNumber = 4;
  inline const ::std::string& server_av_address() const;
  inline void set_server_av_address(const ::std::string& value);
  inline void set_server_av_address(const char* value);
  inline void set_server_av_address(const char* value, size_t size);
  inline ::std::string* mutable_server_av_address();
  inline ::std::string* release_server_av_address();
  inline void set_allocated_server_av_address(::std::string* server_av_address);

  // @@protoc_insertion_point(class_scope:proto.server_hello)
 private:
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_pub_key();
  inline void clear_has_random_pub_key();
  inline void set_has_server_av_address();
  inline void clear_has_server_av_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* servername_;
  ::std::string* random_pub_key_;
  ::std::string* server_av_address_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static server_hello* default_instance_;
};
// -------------------------------------------------------------------

class login : public ::google::protobuf::Message {
 public:
  login();
  virtual ~login();

  login(const login& from);

  inline login& operator=(const login& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline login& operator=(login&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  login(login&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login& default_instance();

  void Swap(login* other);

  // implements Message ----------------------------------------------

  login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login& from);
  void MergeFrom(const login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user_cert = 1;
  inline bool has_user_cert() const;
  inline void clear_user_cert();
  static const int kUserCertFieldNumber = 1;
  inline const ::std::string& user_cert() const;
  inline void set_user_cert(const ::std::string& value);
  inline void set_user_cert(const char* value);
  inline void set_user_cert(const void* value, size_t size);
  inline ::std::string* mutable_user_cert();
  inline ::std::string* release_user_cert();
  inline void set_allocated_user_cert(::std::string* user_cert);

  // required bytes encryped_radom_key = 2;
  inline bool has_encryped_radom_key() const;
  inline void clear_encryped_radom_key();
  static const int kEncrypedRadomKeyFieldNumber = 2;
  inline const ::std::string& encryped_radom_key() const;
  inline void set_encryped_radom_key(const ::std::string& value);
  inline void set_encryped_radom_key(const char* value);
  inline void set_encryped_radom_key(const void* value, size_t size);
  inline ::std::string* mutable_encryped_radom_key();
  inline ::std::string* release_encryped_radom_key();
  inline void set_allocated_encryped_radom_key(::std::string* encryped_radom_key);

  // optional string other_info = 3;
  inline bool has_other_info() const;
  inline void clear_other_info();
  static const int kOtherInfoFieldNumber = 3;
  inline const ::std::string& other_info() const;
  inline void set_other_info(const ::std::string& value);
  inline void set_other_info(const char* value);
  inline void set_other_info(const char* value, size_t size);
  inline ::std::string* mutable_other_info();
  inline ::std::string* release_other_info();
  inline void set_allocated_other_info(::std::string* other_info);

  // @@protoc_insertion_point(class_scope:proto.login)
 private:
  inline void set_has_user_cert();
  inline void clear_has_user_cert();
  inline void set_has_encryped_radom_key();
  inline void clear_has_encryped_radom_key();
  inline void set_has_other_info();
  inline void clear_has_other_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_cert_;
  ::std::string* encryped_radom_key_;
  ::std::string* other_info_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static login* default_instance_;
};
// -------------------------------------------------------------------

class login_result : public ::google::protobuf::Message {
 public:
  login_result();
  virtual ~login_result();

  login_result(const login_result& from);

  inline login_result& operator=(const login_result& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline login_result& operator=(login_result&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  login_result(login_result&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_result& default_instance();

  void Swap(login_result* other);

  // implements Message ----------------------------------------------

  login_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_result& from);
  void MergeFrom(const login_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef login_result_login_result_code login_result_code;
  static const login_result_code LOGIN_SUCCEED = login_result_login_result_code_LOGIN_SUCCEED;
  static const login_result_code NO_SUCH_USER = login_result_login_result_code_NO_SUCH_USER;
  static const login_result_code PEREMISSON_DENIED = login_result_login_result_code_PEREMISSON_DENIED;
  static const login_result_code PUBLIC_KEY_MISMATCH = login_result_login_result_code_PUBLIC_KEY_MISMATCH;
  static inline bool login_result_code_IsValid(int value) {
    return login_result_login_result_code_IsValid(value);
  }
  static const login_result_code login_result_code_MIN =
    login_result_login_result_code_login_result_code_MIN;
  static const login_result_code login_result_code_MAX =
    login_result_login_result_code_login_result_code_MAX;
  static const int login_result_code_ARRAYSIZE =
    login_result_login_result_code_login_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  login_result_code_descriptor() {
    return login_result_login_result_code_descriptor();
  }
  static inline const ::std::string& login_result_code_Name(login_result_code value) {
    return login_result_login_result_code_Name(value);
  }
  static inline bool login_result_code_Parse(const ::std::string& name,
      login_result_code* value) {
    return login_result_login_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.login_result.login_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::login_result_login_result_code result() const;
  inline void set_result(::proto::login_result_login_result_code value);

  // @@protoc_insertion_point(class_scope:proto.login_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static login_result* default_instance_;
};
// -------------------------------------------------------------------

class username_availability_check : public ::google::protobuf::Message {
 public:
  username_availability_check();
  virtual ~username_availability_check();

  username_availability_check(const username_availability_check& from);

  inline username_availability_check& operator=(const username_availability_check& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline username_availability_check& operator=(username_availability_check&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  username_availability_check(username_availability_check&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const username_availability_check& default_instance();

  void Swap(username_availability_check* other);

  // implements Message ----------------------------------------------

  username_availability_check* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const username_availability_check& from);
  void MergeFrom(const username_availability_check& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:proto.username_availability_check)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static username_availability_check* default_instance_;
};
// -------------------------------------------------------------------

class username_availability_result : public ::google::protobuf::Message {
 public:
  username_availability_result();
  virtual ~username_availability_result();

  username_availability_result(const username_availability_result& from);

  inline username_availability_result& operator=(const username_availability_result& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline username_availability_result& operator=(username_availability_result&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  username_availability_result(username_availability_result&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const username_availability_result& default_instance();

  void Swap(username_availability_result* other);

  // implements Message ----------------------------------------------

  username_availability_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const username_availability_result& from);
  void MergeFrom(const username_availability_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef username_availability_result_username_availability_result_code username_availability_result_code;
  static const username_availability_result_code NAME_AVAILABLE = username_availability_result_username_availability_result_code_NAME_AVAILABLE;
  static const username_availability_result_code NAME_DISALLOW = username_availability_result_username_availability_result_code_NAME_DISALLOW;
  static const username_availability_result_code NAME_TAKEN = username_availability_result_username_availability_result_code_NAME_TAKEN;
  static inline bool username_availability_result_code_IsValid(int value) {
    return username_availability_result_username_availability_result_code_IsValid(value);
  }
  static const username_availability_result_code username_availability_result_code_MIN =
    username_availability_result_username_availability_result_code_username_availability_result_code_MIN;
  static const username_availability_result_code username_availability_result_code_MAX =
    username_availability_result_username_availability_result_code_username_availability_result_code_MAX;
  static const int username_availability_result_code_ARRAYSIZE =
    username_availability_result_username_availability_result_code_username_availability_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  username_availability_result_code_descriptor() {
    return username_availability_result_username_availability_result_code_descriptor();
  }
  static inline const ::std::string& username_availability_result_code_Name(username_availability_result_code value) {
    return username_availability_result_username_availability_result_code_Name(value);
  }
  static inline bool username_availability_result_code_Parse(const ::std::string& name,
      username_availability_result_code* value) {
    return username_availability_result_username_availability_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.username_availability_result.username_availability_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::username_availability_result_username_availability_result_code result() const;
  inline void set_result(::proto::username_availability_result_username_availability_result_code value);

  // @@protoc_insertion_point(class_scope:proto.username_availability_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static username_availability_result* default_instance_;
};
// -------------------------------------------------------------------

class user_register : public ::google::protobuf::Message {
 public:
  user_register();
  virtual ~user_register();

  user_register(const user_register& from);

  inline user_register& operator=(const user_register& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_register& operator=(user_register&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_register(user_register&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_register& default_instance();

  void Swap(user_register* other);

  // implements Message ----------------------------------------------

  user_register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_register& from);
  void MergeFrom(const user_register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required bytes rsa_pubkey = 2;
  inline bool has_rsa_pubkey() const;
  inline void clear_rsa_pubkey();
  static const int kRsaPubkeyFieldNumber = 2;
  inline const ::std::string& rsa_pubkey() const;
  inline void set_rsa_pubkey(const ::std::string& value);
  inline void set_rsa_pubkey(const char* value);
  inline void set_rsa_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_rsa_pubkey();
  inline ::std::string* release_rsa_pubkey();
  inline void set_allocated_rsa_pubkey(::std::string* rsa_pubkey);

  // required bytes CSR = 3;
  inline bool has_csr() const;
  inline void clear_csr();
  static const int kCSRFieldNumber = 3;
  inline const ::std::string& csr() const;
  inline void set_csr(const ::std::string& value);
  inline void set_csr(const char* value);
  inline void set_csr(const void* value, size_t size);
  inline ::std::string* mutable_csr();
  inline ::std::string* release_csr();
  inline void set_allocated_csr(::std::string* csr);

  // optional string mail_address = 4;
  inline bool has_mail_address() const;
  inline void clear_mail_address();
  static const int kMailAddressFieldNumber = 4;
  inline const ::std::string& mail_address() const;
  inline void set_mail_address(const ::std::string& value);
  inline void set_mail_address(const char* value);
  inline void set_mail_address(const char* value, size_t size);
  inline ::std::string* mutable_mail_address();
  inline ::std::string* release_mail_address();
  inline void set_allocated_mail_address(::std::string* mail_address);

  // optional string cell_phone = 5;
  inline bool has_cell_phone() const;
  inline void clear_cell_phone();
  static const int kCellPhoneFieldNumber = 5;
  inline const ::std::string& cell_phone() const;
  inline void set_cell_phone(const ::std::string& value);
  inline void set_cell_phone(const char* value);
  inline void set_cell_phone(const char* value, size_t size);
  inline ::std::string* mutable_cell_phone();
  inline ::std::string* release_cell_phone();
  inline void set_allocated_cell_phone(::std::string* cell_phone);

  // @@protoc_insertion_point(class_scope:proto.user_register)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_rsa_pubkey();
  inline void clear_has_rsa_pubkey();
  inline void set_has_csr();
  inline void clear_has_csr();
  inline void set_has_mail_address();
  inline void clear_has_mail_address();
  inline void set_has_cell_phone();
  inline void clear_has_cell_phone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* rsa_pubkey_;
  ::std::string* csr_;
  ::std::string* mail_address_;
  ::std::string* cell_phone_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_register* default_instance_;
};
// -------------------------------------------------------------------

class user_register_result : public ::google::protobuf::Message {
 public:
  user_register_result();
  virtual ~user_register_result();

  user_register_result(const user_register_result& from);

  inline user_register_result& operator=(const user_register_result& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_register_result& operator=(user_register_result&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_register_result(user_register_result&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_register_result& default_instance();

  void Swap(user_register_result* other);

  // implements Message ----------------------------------------------

  user_register_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_register_result& from);
  void MergeFrom(const user_register_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef user_register_result_user_register_result_code user_register_result_code;
  static const user_register_result_code REGISTER_SUCCEED = user_register_result_user_register_result_code_REGISTER_SUCCEED;
  static const user_register_result_code REGISTER_SUCCEED_PENDDING_CERT = user_register_result_user_register_result_code_REGISTER_SUCCEED_PENDDING_CERT;
  static const user_register_result_code REGISTER_FAILED_NAME_TAKEN = user_register_result_user_register_result_code_REGISTER_FAILED_NAME_TAKEN;
  static const user_register_result_code REGISTER_FAILED_TOO_SHORT_KEY = user_register_result_user_register_result_code_REGISTER_FAILED_TOO_SHORT_KEY;
  static const user_register_result_code REGISTER_FAILED_NAME_DISALLOW = user_register_result_user_register_result_code_REGISTER_FAILED_NAME_DISALLOW;
  static const user_register_result_code REGISTER_FAILED_CA_DOWN = user_register_result_user_register_result_code_REGISTER_FAILED_CA_DOWN;
  static const user_register_result_code REGISTER_FAILED_CSR_VERIFY_FAILURE = user_register_result_user_register_result_code_REGISTER_FAILED_CSR_VERIFY_FAILURE;
  static inline bool user_register_result_code_IsValid(int value) {
    return user_register_result_user_register_result_code_IsValid(value);
  }
  static const user_register_result_code user_register_result_code_MIN =
    user_register_result_user_register_result_code_user_register_result_code_MIN;
  static const user_register_result_code user_register_result_code_MAX =
    user_register_result_user_register_result_code_user_register_result_code_MAX;
  static const int user_register_result_code_ARRAYSIZE =
    user_register_result_user_register_result_code_user_register_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  user_register_result_code_descriptor() {
    return user_register_result_user_register_result_code_descriptor();
  }
  static inline const ::std::string& user_register_result_code_Name(user_register_result_code value) {
    return user_register_result_user_register_result_code_Name(value);
  }
  static inline bool user_register_result_code_Parse(const ::std::string& name,
      user_register_result_code* value) {
    return user_register_result_user_register_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.user_register_result.user_register_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::user_register_result_user_register_result_code result() const;
  inline void set_result(::proto::user_register_result_user_register_result_code value);

  // optional bytes cert = 2;
  inline bool has_cert() const;
  inline void clear_cert();
  static const int kCertFieldNumber = 2;
  inline const ::std::string& cert() const;
  inline void set_cert(const ::std::string& value);
  inline void set_cert(const char* value);
  inline void set_cert(const void* value, size_t size);
  inline ::std::string* mutable_cert();
  inline ::std::string* release_cert();
  inline void set_allocated_cert(::std::string* cert);

  // @@protoc_insertion_point(class_scope:proto.user_register_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_cert();
  inline void clear_has_cert();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cert_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_register_result* default_instance_;
};
// -------------------------------------------------------------------

class user_cert_lost_request : public ::google::protobuf::Message {
 public:
  user_cert_lost_request();
  virtual ~user_cert_lost_request();

  user_cert_lost_request(const user_cert_lost_request& from);

  inline user_cert_lost_request& operator=(const user_cert_lost_request& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_cert_lost_request& operator=(user_cert_lost_request&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_cert_lost_request(user_cert_lost_request&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_cert_lost_request& default_instance();

  void Swap(user_cert_lost_request* other);

  // implements Message ----------------------------------------------

  user_cert_lost_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_cert_lost_request& from);
  void MergeFrom(const user_cert_lost_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string mail_address = 3;
  inline bool has_mail_address() const;
  inline void clear_mail_address();
  static const int kMailAddressFieldNumber = 3;
  inline const ::std::string& mail_address() const;
  inline void set_mail_address(const ::std::string& value);
  inline void set_mail_address(const char* value);
  inline void set_mail_address(const char* value, size_t size);
  inline ::std::string* mutable_mail_address();
  inline ::std::string* release_mail_address();
  inline void set_allocated_mail_address(::std::string* mail_address);

  // optional string cell_phone = 4;
  inline bool has_cell_phone() const;
  inline void clear_cell_phone();
  static const int kCellPhoneFieldNumber = 4;
  inline const ::std::string& cell_phone() const;
  inline void set_cell_phone(const ::std::string& value);
  inline void set_cell_phone(const char* value);
  inline void set_cell_phone(const char* value, size_t size);
  inline ::std::string* mutable_cell_phone();
  inline ::std::string* release_cell_phone();
  inline void set_allocated_cell_phone(::std::string* cell_phone);

  // @@protoc_insertion_point(class_scope:proto.user_cert_lost_request)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_mail_address();
  inline void clear_has_mail_address();
  inline void set_has_cell_phone();
  inline void clear_has_cell_phone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* mail_address_;
  ::std::string* cell_phone_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_cert_lost_request* default_instance_;
};
// -------------------------------------------------------------------

class user_cert_lost_verify : public ::google::protobuf::Message {
 public:
  user_cert_lost_verify();
  virtual ~user_cert_lost_verify();

  user_cert_lost_verify(const user_cert_lost_verify& from);

  inline user_cert_lost_verify& operator=(const user_cert_lost_verify& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_cert_lost_verify& operator=(user_cert_lost_verify&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_cert_lost_verify(user_cert_lost_verify&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_cert_lost_verify& default_instance();

  void Swap(user_cert_lost_verify* other);

  // implements Message ----------------------------------------------

  user_cert_lost_verify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_cert_lost_verify& from);
  void MergeFrom(const user_cert_lost_verify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string secret_code = 1;
  inline bool has_secret_code() const;
  inline void clear_secret_code();
  static const int kSecretCodeFieldNumber = 1;
  inline const ::std::string& secret_code() const;
  inline void set_secret_code(const ::std::string& value);
  inline void set_secret_code(const char* value);
  inline void set_secret_code(const char* value, size_t size);
  inline ::std::string* mutable_secret_code();
  inline ::std::string* release_secret_code();
  inline void set_allocated_secret_code(::std::string* secret_code);

  // @@protoc_insertion_point(class_scope:proto.user_cert_lost_verify)
 private:
  inline void set_has_secret_code();
  inline void clear_has_secret_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* secret_code_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_cert_lost_verify* default_instance_;
};
// ===================================================================


// ===================================================================

// client_hello

// required string client = 1;
inline bool client_hello::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_hello::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_hello::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_hello::clear_client() {
  if (client_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_->clear();
  }
  clear_has_client();
}
inline const ::std::string& client_hello::client() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.client)
  return *client_;
}
inline void client_hello::set_client(const ::std::string& value) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  client_->assign(value);
  // @@protoc_insertion_point(field_set:proto.client_hello.client)
}
inline void client_hello::set_client(const char* value) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  client_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.client_hello.client)
}
inline void client_hello::set_client(const char* value, size_t size) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  client_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.client)
}
inline ::std::string* client_hello::mutable_client() {
  set_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.client_hello.client)
  return client_;
}
inline ::std::string* client_hello::release_client() {
  clear_has_client();
  if (client_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_;
    client_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_hello::set_allocated_client(::std::string* client) {
  if (client_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_;
  }
  if (client) {
    set_has_client();
    client_ = client;
  } else {
    clear_has_client();
    client_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.client)
}

// required uint32 version = 2;
inline bool client_hello::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_hello::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_hello::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 client_hello::version() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.version)
  return version_;
}
inline void client_hello::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.client_hello.version)
}

// required bytes random_g = 3;
inline bool client_hello::has_random_g() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_hello::set_has_random_g() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_hello::clear_has_random_g() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_hello::clear_random_g() {
  if (random_g_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_g_->clear();
  }
  clear_has_random_g();
}
inline const ::std::string& client_hello::random_g() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_g)
  return *random_g_;
}
inline void client_hello::set_random_g(const ::std::string& value) {
  set_has_random_g();
  if (random_g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_g_ = new ::std::string;
  }
  random_g_->assign(value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_g)
}
inline void client_hello::set_random_g(const char* value) {
  set_has_random_g();
  if (random_g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_g_ = new ::std::string;
  }
  random_g_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_g)
}
inline void client_hello::set_random_g(const void* value, size_t size) {
  set_has_random_g();
  if (random_g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_g_ = new ::std::string;
  }
  random_g_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_g)
}
inline ::std::string* client_hello::mutable_random_g() {
  set_has_random_g();
  if (random_g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_g_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_g)
  return random_g_;
}
inline ::std::string* client_hello::release_random_g() {
  clear_has_random_g();
  if (random_g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = random_g_;
    random_g_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_hello::set_allocated_random_g(::std::string* random_g) {
  if (random_g_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete random_g_;
  }
  if (random_g) {
    set_has_random_g();
    random_g_ = random_g;
  } else {
    clear_has_random_g();
    random_g_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_g)
}

// required bytes random_p = 4;
inline bool client_hello::has_random_p() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_hello::set_has_random_p() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_hello::clear_has_random_p() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_hello::clear_random_p() {
  if (random_p_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_p_->clear();
  }
  clear_has_random_p();
}
inline const ::std::string& client_hello::random_p() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_p)
  return *random_p_;
}
inline void client_hello::set_random_p(const ::std::string& value) {
  set_has_random_p();
  if (random_p_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_p_ = new ::std::string;
  }
  random_p_->assign(value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_p)
}
inline void client_hello::set_random_p(const char* value) {
  set_has_random_p();
  if (random_p_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_p_ = new ::std::string;
  }
  random_p_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_p)
}
inline void client_hello::set_random_p(const void* value, size_t size) {
  set_has_random_p();
  if (random_p_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_p_ = new ::std::string;
  }
  random_p_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_p)
}
inline ::std::string* client_hello::mutable_random_p() {
  set_has_random_p();
  if (random_p_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_p_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_p)
  return random_p_;
}
inline ::std::string* client_hello::release_random_p() {
  clear_has_random_p();
  if (random_p_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = random_p_;
    random_p_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_hello::set_allocated_random_p(::std::string* random_p) {
  if (random_p_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete random_p_;
  }
  if (random_p) {
    set_has_random_p();
    random_p_ = random_p;
  } else {
    clear_has_random_p();
    random_p_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_p)
}

// required bytes random_pub_key = 5;
inline bool client_hello::has_random_pub_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_hello::set_has_random_pub_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_hello::clear_has_random_pub_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_hello::clear_random_pub_key() {
  if (random_pub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_->clear();
  }
  clear_has_random_pub_key();
}
inline const ::std::string& client_hello::random_pub_key() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_pub_key)
  return *random_pub_key_;
}
inline void client_hello::set_random_pub_key(const ::std::string& value) {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  random_pub_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_pub_key)
}
inline void client_hello::set_random_pub_key(const char* value) {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  random_pub_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_pub_key)
}
inline void client_hello::set_random_pub_key(const void* value, size_t size) {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  random_pub_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_pub_key)
}
inline ::std::string* client_hello::mutable_random_pub_key() {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_pub_key)
  return random_pub_key_;
}
inline ::std::string* client_hello::release_random_pub_key() {
  clear_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = random_pub_key_;
    random_pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void client_hello::set_allocated_random_pub_key(::std::string* random_pub_key) {
  if (random_pub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete random_pub_key_;
  }
  if (random_pub_key) {
    set_has_random_pub_key();
    random_pub_key_ = random_pub_key;
  } else {
    clear_has_random_pub_key();
    random_pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_pub_key)
}

// -------------------------------------------------------------------

// server_hello

// required string servername = 1;
inline bool server_hello::has_servername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void server_hello::set_has_servername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void server_hello::clear_has_servername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void server_hello::clear_servername() {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& server_hello::servername() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.servername)
  return *servername_;
}
inline void server_hello::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set:proto.server_hello.servername)
}
inline void server_hello::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.server_hello.servername)
}
inline void server_hello::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.servername)
}
inline ::std::string* server_hello::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.server_hello.servername)
  return servername_;
}
inline ::std::string* server_hello::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void server_hello::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.servername)
}

// required uint32 version = 2;
inline bool server_hello::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void server_hello::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void server_hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void server_hello::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 server_hello::version() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.version)
  return version_;
}
inline void server_hello::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.server_hello.version)
}

// required bytes random_pub_key = 3;
inline bool server_hello::has_random_pub_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void server_hello::set_has_random_pub_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void server_hello::clear_has_random_pub_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void server_hello::clear_random_pub_key() {
  if (random_pub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_->clear();
  }
  clear_has_random_pub_key();
}
inline const ::std::string& server_hello::random_pub_key() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.random_pub_key)
  return *random_pub_key_;
}
inline void server_hello::set_random_pub_key(const ::std::string& value) {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  random_pub_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.server_hello.random_pub_key)
}
inline void server_hello::set_random_pub_key(const char* value) {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  random_pub_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.server_hello.random_pub_key)
}
inline void server_hello::set_random_pub_key(const void* value, size_t size) {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  random_pub_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.random_pub_key)
}
inline ::std::string* server_hello::mutable_random_pub_key() {
  set_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    random_pub_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.server_hello.random_pub_key)
  return random_pub_key_;
}
inline ::std::string* server_hello::release_random_pub_key() {
  clear_has_random_pub_key();
  if (random_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = random_pub_key_;
    random_pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void server_hello::set_allocated_random_pub_key(::std::string* random_pub_key) {
  if (random_pub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete random_pub_key_;
  }
  if (random_pub_key) {
    set_has_random_pub_key();
    random_pub_key_ = random_pub_key;
  } else {
    clear_has_random_pub_key();
    random_pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.random_pub_key)
}

// required string server_av_address = 4;
inline bool server_hello::has_server_av_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void server_hello::set_has_server_av_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void server_hello::clear_has_server_av_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void server_hello::clear_server_av_address() {
  if (server_av_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_av_address_->clear();
  }
  clear_has_server_av_address();
}
inline const ::std::string& server_hello::server_av_address() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.server_av_address)
  return *server_av_address_;
}
inline void server_hello::set_server_av_address(const ::std::string& value) {
  set_has_server_av_address();
  if (server_av_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_av_address_ = new ::std::string;
  }
  server_av_address_->assign(value);
  // @@protoc_insertion_point(field_set:proto.server_hello.server_av_address)
}
inline void server_hello::set_server_av_address(const char* value) {
  set_has_server_av_address();
  if (server_av_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_av_address_ = new ::std::string;
  }
  server_av_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.server_hello.server_av_address)
}
inline void server_hello::set_server_av_address(const char* value, size_t size) {
  set_has_server_av_address();
  if (server_av_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_av_address_ = new ::std::string;
  }
  server_av_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.server_av_address)
}
inline ::std::string* server_hello::mutable_server_av_address() {
  set_has_server_av_address();
  if (server_av_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_av_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.server_hello.server_av_address)
  return server_av_address_;
}
inline ::std::string* server_hello::release_server_av_address() {
  clear_has_server_av_address();
  if (server_av_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_av_address_;
    server_av_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void server_hello::set_allocated_server_av_address(::std::string* server_av_address) {
  if (server_av_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_av_address_;
  }
  if (server_av_address) {
    set_has_server_av_address();
    server_av_address_ = server_av_address;
  } else {
    clear_has_server_av_address();
    server_av_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.server_av_address)
}

// -------------------------------------------------------------------

// login

// required bytes user_cert = 1;
inline bool login::has_user_cert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login::set_has_user_cert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login::clear_has_user_cert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login::clear_user_cert() {
  if (user_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_cert_->clear();
  }
  clear_has_user_cert();
}
inline const ::std::string& login::user_cert() const {
  // @@protoc_insertion_point(field_get:proto.login.user_cert)
  return *user_cert_;
}
inline void login::set_user_cert(const ::std::string& value) {
  set_has_user_cert();
  if (user_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_cert_ = new ::std::string;
  }
  user_cert_->assign(value);
  // @@protoc_insertion_point(field_set:proto.login.user_cert)
}
inline void login::set_user_cert(const char* value) {
  set_has_user_cert();
  if (user_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_cert_ = new ::std::string;
  }
  user_cert_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.login.user_cert)
}
inline void login::set_user_cert(const void* value, size_t size) {
  set_has_user_cert();
  if (user_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_cert_ = new ::std::string;
  }
  user_cert_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.login.user_cert)
}
inline ::std::string* login::mutable_user_cert() {
  set_has_user_cert();
  if (user_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_cert_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.login.user_cert)
  return user_cert_;
}
inline ::std::string* login::release_user_cert() {
  clear_has_user_cert();
  if (user_cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_cert_;
    user_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_user_cert(::std::string* user_cert) {
  if (user_cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_cert_;
  }
  if (user_cert) {
    set_has_user_cert();
    user_cert_ = user_cert;
  } else {
    clear_has_user_cert();
    user_cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.login.user_cert)
}

// required bytes encryped_radom_key = 2;
inline bool login::has_encryped_radom_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login::set_has_encryped_radom_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login::clear_has_encryped_radom_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login::clear_encryped_radom_key() {
  if (encryped_radom_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_->clear();
  }
  clear_has_encryped_radom_key();
}
inline const ::std::string& login::encryped_radom_key() const {
  // @@protoc_insertion_point(field_get:proto.login.encryped_radom_key)
  return *encryped_radom_key_;
}
inline void login::set_encryped_radom_key(const ::std::string& value) {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  encryped_radom_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.login.encryped_radom_key)
}
inline void login::set_encryped_radom_key(const char* value) {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  encryped_radom_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.login.encryped_radom_key)
}
inline void login::set_encryped_radom_key(const void* value, size_t size) {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  encryped_radom_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.login.encryped_radom_key)
}
inline ::std::string* login::mutable_encryped_radom_key() {
  set_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encryped_radom_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.login.encryped_radom_key)
  return encryped_radom_key_;
}
inline ::std::string* login::release_encryped_radom_key() {
  clear_has_encryped_radom_key();
  if (encryped_radom_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encryped_radom_key_;
    encryped_radom_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_encryped_radom_key(::std::string* encryped_radom_key) {
  if (encryped_radom_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encryped_radom_key_;
  }
  if (encryped_radom_key) {
    set_has_encryped_radom_key();
    encryped_radom_key_ = encryped_radom_key;
  } else {
    clear_has_encryped_radom_key();
    encryped_radom_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.login.encryped_radom_key)
}

// optional string other_info = 3;
inline bool login::has_other_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login::set_has_other_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login::clear_has_other_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login::clear_other_info() {
  if (other_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_->clear();
  }
  clear_has_other_info();
}
inline const ::std::string& login::other_info() const {
  // @@protoc_insertion_point(field_get:proto.login.other_info)
  return *other_info_;
}
inline void login::set_other_info(const ::std::string& value) {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  other_info_->assign(value);
  // @@protoc_insertion_point(field_set:proto.login.other_info)
}
inline void login::set_other_info(const char* value) {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  other_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.login.other_info)
}
inline void login::set_other_info(const char* value, size_t size) {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  other_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.login.other_info)
}
inline ::std::string* login::mutable_other_info() {
  set_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    other_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.login.other_info)
  return other_info_;
}
inline ::std::string* login::release_other_info() {
  clear_has_other_info();
  if (other_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = other_info_;
    other_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void login::set_allocated_other_info(::std::string* other_info) {
  if (other_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete other_info_;
  }
  if (other_info) {
    set_has_other_info();
    other_info_ = other_info;
  } else {
    clear_has_other_info();
    other_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.login.other_info)
}

// -------------------------------------------------------------------

// login_result

// required .proto.login_result.login_result_code result = 1;
inline bool login_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::login_result_login_result_code login_result::result() const {
  // @@protoc_insertion_point(field_get:proto.login_result.result)
  return static_cast< ::proto::login_result_login_result_code >(result_);
}
inline void login_result::set_result(::proto::login_result_login_result_code value) {
  assert(::proto::login_result_login_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.login_result.result)
}

// -------------------------------------------------------------------

// username_availability_check

// required string user_name = 1;
inline bool username_availability_check::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void username_availability_check::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void username_availability_check::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void username_availability_check::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& username_availability_check::user_name() const {
  // @@protoc_insertion_point(field_get:proto.username_availability_check.user_name)
  return *user_name_;
}
inline void username_availability_check::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:proto.username_availability_check.user_name)
}
inline void username_availability_check::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.username_availability_check.user_name)
}
inline void username_availability_check::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.username_availability_check.user_name)
}
inline ::std::string* username_availability_check::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.username_availability_check.user_name)
  return user_name_;
}
inline ::std::string* username_availability_check::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void username_availability_check::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.username_availability_check.user_name)
}

// -------------------------------------------------------------------

// username_availability_result

// required .proto.username_availability_result.username_availability_result_code result = 1;
inline bool username_availability_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void username_availability_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void username_availability_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void username_availability_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::username_availability_result_username_availability_result_code username_availability_result::result() const {
  // @@protoc_insertion_point(field_get:proto.username_availability_result.result)
  return static_cast< ::proto::username_availability_result_username_availability_result_code >(result_);
}
inline void username_availability_result::set_result(::proto::username_availability_result_username_availability_result_code value) {
  assert(::proto::username_availability_result_username_availability_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.username_availability_result.result)
}

// -------------------------------------------------------------------

// user_register

// required string user_name = 1;
inline bool user_register::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_register::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_register::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_register::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& user_register::user_name() const {
  // @@protoc_insertion_point(field_get:proto.user_register.user_name)
  return *user_name_;
}
inline void user_register::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.user_name)
}
inline void user_register::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.user_name)
}
inline void user_register::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.user_name)
}
inline ::std::string* user_register::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.user_name)
  return user_name_;
}
inline ::std::string* user_register::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.user_name)
}

// required bytes rsa_pubkey = 2;
inline bool user_register::has_rsa_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_register::set_has_rsa_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_register::clear_has_rsa_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_register::clear_rsa_pubkey() {
  if (rsa_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_->clear();
  }
  clear_has_rsa_pubkey();
}
inline const ::std::string& user_register::rsa_pubkey() const {
  // @@protoc_insertion_point(field_get:proto.user_register.rsa_pubkey)
  return *rsa_pubkey_;
}
inline void user_register::set_rsa_pubkey(const ::std::string& value) {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  rsa_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.rsa_pubkey)
}
inline void user_register::set_rsa_pubkey(const char* value) {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  rsa_pubkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.rsa_pubkey)
}
inline void user_register::set_rsa_pubkey(const void* value, size_t size) {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  rsa_pubkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.rsa_pubkey)
}
inline ::std::string* user_register::mutable_rsa_pubkey() {
  set_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsa_pubkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.rsa_pubkey)
  return rsa_pubkey_;
}
inline ::std::string* user_register::release_rsa_pubkey() {
  clear_has_rsa_pubkey();
  if (rsa_pubkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rsa_pubkey_;
    rsa_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_rsa_pubkey(::std::string* rsa_pubkey) {
  if (rsa_pubkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rsa_pubkey_;
  }
  if (rsa_pubkey) {
    set_has_rsa_pubkey();
    rsa_pubkey_ = rsa_pubkey;
  } else {
    clear_has_rsa_pubkey();
    rsa_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.rsa_pubkey)
}

// required bytes CSR = 3;
inline bool user_register::has_csr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_register::set_has_csr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_register::clear_has_csr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_register::clear_csr() {
  if (csr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    csr_->clear();
  }
  clear_has_csr();
}
inline const ::std::string& user_register::csr() const {
  // @@protoc_insertion_point(field_get:proto.user_register.CSR)
  return *csr_;
}
inline void user_register::set_csr(const ::std::string& value) {
  set_has_csr();
  if (csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    csr_ = new ::std::string;
  }
  csr_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.CSR)
}
inline void user_register::set_csr(const char* value) {
  set_has_csr();
  if (csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    csr_ = new ::std::string;
  }
  csr_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.CSR)
}
inline void user_register::set_csr(const void* value, size_t size) {
  set_has_csr();
  if (csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    csr_ = new ::std::string;
  }
  csr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.CSR)
}
inline ::std::string* user_register::mutable_csr() {
  set_has_csr();
  if (csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    csr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.CSR)
  return csr_;
}
inline ::std::string* user_register::release_csr() {
  clear_has_csr();
  if (csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = csr_;
    csr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_csr(::std::string* csr) {
  if (csr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete csr_;
  }
  if (csr) {
    set_has_csr();
    csr_ = csr;
  } else {
    clear_has_csr();
    csr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.CSR)
}

// optional string mail_address = 4;
inline bool user_register::has_mail_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_register::set_has_mail_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_register::clear_has_mail_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_register::clear_mail_address() {
  if (mail_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_->clear();
  }
  clear_has_mail_address();
}
inline const ::std::string& user_register::mail_address() const {
  // @@protoc_insertion_point(field_get:proto.user_register.mail_address)
  return *mail_address_;
}
inline void user_register::set_mail_address(const ::std::string& value) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.mail_address)
}
inline void user_register::set_mail_address(const char* value) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.mail_address)
}
inline void user_register::set_mail_address(const char* value, size_t size) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.mail_address)
}
inline ::std::string* user_register::mutable_mail_address() {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.mail_address)
  return mail_address_;
}
inline ::std::string* user_register::release_mail_address() {
  clear_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mail_address_;
    mail_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_mail_address(::std::string* mail_address) {
  if (mail_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_address_;
  }
  if (mail_address) {
    set_has_mail_address();
    mail_address_ = mail_address;
  } else {
    clear_has_mail_address();
    mail_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.mail_address)
}

// optional string cell_phone = 5;
inline bool user_register::has_cell_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_register::set_has_cell_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_register::clear_has_cell_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_register::clear_cell_phone() {
  if (cell_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_->clear();
  }
  clear_has_cell_phone();
}
inline const ::std::string& user_register::cell_phone() const {
  // @@protoc_insertion_point(field_get:proto.user_register.cell_phone)
  return *cell_phone_;
}
inline void user_register::set_cell_phone(const ::std::string& value) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register.cell_phone)
}
inline void user_register::set_cell_phone(const char* value) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register.cell_phone)
}
inline void user_register::set_cell_phone(const char* value, size_t size) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.cell_phone)
}
inline ::std::string* user_register::mutable_cell_phone() {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register.cell_phone)
  return cell_phone_;
}
inline ::std::string* user_register::release_cell_phone() {
  clear_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cell_phone_;
    cell_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register::set_allocated_cell_phone(::std::string* cell_phone) {
  if (cell_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cell_phone_;
  }
  if (cell_phone) {
    set_has_cell_phone();
    cell_phone_ = cell_phone;
  } else {
    clear_has_cell_phone();
    cell_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.cell_phone)
}

// -------------------------------------------------------------------

// user_register_result

// required .proto.user_register_result.user_register_result_code result = 1;
inline bool user_register_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_register_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_register_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_register_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::user_register_result_user_register_result_code user_register_result::result() const {
  // @@protoc_insertion_point(field_get:proto.user_register_result.result)
  return static_cast< ::proto::user_register_result_user_register_result_code >(result_);
}
inline void user_register_result::set_result(::proto::user_register_result_user_register_result_code value) {
  assert(::proto::user_register_result_user_register_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.user_register_result.result)
}

// optional bytes cert = 2;
inline bool user_register_result::has_cert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_register_result::set_has_cert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_register_result::clear_has_cert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_register_result::clear_cert() {
  if (cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_->clear();
  }
  clear_has_cert();
}
inline const ::std::string& user_register_result::cert() const {
  // @@protoc_insertion_point(field_get:proto.user_register_result.cert)
  return *cert_;
}
inline void user_register_result::set_cert(const ::std::string& value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_register_result.cert)
}
inline void user_register_result::set_cert(const char* value) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_ = new ::std::string;
  }
  cert_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_register_result.cert)
}
inline void user_register_result::set_cert(const void* value, size_t size) {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_ = new ::std::string;
  }
  cert_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_register_result.cert)
}
inline ::std::string* user_register_result::mutable_cert() {
  set_has_cert();
  if (cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_register_result.cert)
  return cert_;
}
inline ::std::string* user_register_result::release_cert() {
  clear_has_cert();
  if (cert_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cert_;
    cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_register_result::set_allocated_cert(::std::string* cert) {
  if (cert_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cert_;
  }
  if (cert) {
    set_has_cert();
    cert_ = cert;
  } else {
    clear_has_cert();
    cert_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_register_result.cert)
}

// -------------------------------------------------------------------

// user_cert_lost_request

// required string user_name = 1;
inline bool user_cert_lost_request::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_cert_lost_request::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_cert_lost_request::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_cert_lost_request::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& user_cert_lost_request::user_name() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_request.user_name)
  return *user_name_;
}
inline void user_cert_lost_request::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_request.user_name)
}
inline void user_cert_lost_request::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_request.user_name)
}
inline void user_cert_lost_request::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_request.user_name)
}
inline ::std::string* user_cert_lost_request::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_request.user_name)
  return user_name_;
}
inline ::std::string* user_cert_lost_request::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_cert_lost_request::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_request.user_name)
}

// optional string mail_address = 3;
inline bool user_cert_lost_request::has_mail_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_cert_lost_request::set_has_mail_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_cert_lost_request::clear_has_mail_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_cert_lost_request::clear_mail_address() {
  if (mail_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_->clear();
  }
  clear_has_mail_address();
}
inline const ::std::string& user_cert_lost_request::mail_address() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_request.mail_address)
  return *mail_address_;
}
inline void user_cert_lost_request::set_mail_address(const ::std::string& value) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_request.mail_address)
}
inline void user_cert_lost_request::set_mail_address(const char* value) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_request.mail_address)
}
inline void user_cert_lost_request::set_mail_address(const char* value, size_t size) {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  mail_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_request.mail_address)
}
inline ::std::string* user_cert_lost_request::mutable_mail_address() {
  set_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mail_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_request.mail_address)
  return mail_address_;
}
inline ::std::string* user_cert_lost_request::release_mail_address() {
  clear_has_mail_address();
  if (mail_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mail_address_;
    mail_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_cert_lost_request::set_allocated_mail_address(::std::string* mail_address) {
  if (mail_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mail_address_;
  }
  if (mail_address) {
    set_has_mail_address();
    mail_address_ = mail_address;
  } else {
    clear_has_mail_address();
    mail_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_request.mail_address)
}

// optional string cell_phone = 4;
inline bool user_cert_lost_request::has_cell_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_cert_lost_request::set_has_cell_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_cert_lost_request::clear_has_cell_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_cert_lost_request::clear_cell_phone() {
  if (cell_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_->clear();
  }
  clear_has_cell_phone();
}
inline const ::std::string& user_cert_lost_request::cell_phone() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_request.cell_phone)
  return *cell_phone_;
}
inline void user_cert_lost_request::set_cell_phone(const ::std::string& value) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_request.cell_phone)
}
inline void user_cert_lost_request::set_cell_phone(const char* value) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_request.cell_phone)
}
inline void user_cert_lost_request::set_cell_phone(const char* value, size_t size) {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  cell_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_request.cell_phone)
}
inline ::std::string* user_cert_lost_request::mutable_cell_phone() {
  set_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cell_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_request.cell_phone)
  return cell_phone_;
}
inline ::std::string* user_cert_lost_request::release_cell_phone() {
  clear_has_cell_phone();
  if (cell_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cell_phone_;
    cell_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_cert_lost_request::set_allocated_cell_phone(::std::string* cell_phone) {
  if (cell_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cell_phone_;
  }
  if (cell_phone) {
    set_has_cell_phone();
    cell_phone_ = cell_phone;
  } else {
    clear_has_cell_phone();
    cell_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_request.cell_phone)
}

// -------------------------------------------------------------------

// user_cert_lost_verify

// required string secret_code = 1;
inline bool user_cert_lost_verify::has_secret_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_cert_lost_verify::set_has_secret_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_cert_lost_verify::clear_has_secret_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_cert_lost_verify::clear_secret_code() {
  if (secret_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_code_->clear();
  }
  clear_has_secret_code();
}
inline const ::std::string& user_cert_lost_verify::secret_code() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_verify.secret_code)
  return *secret_code_;
}
inline void user_cert_lost_verify::set_secret_code(const ::std::string& value) {
  set_has_secret_code();
  if (secret_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_code_ = new ::std::string;
  }
  secret_code_->assign(value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_verify.secret_code)
}
inline void user_cert_lost_verify::set_secret_code(const char* value) {
  set_has_secret_code();
  if (secret_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_code_ = new ::std::string;
  }
  secret_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_verify.secret_code)
}
inline void user_cert_lost_verify::set_secret_code(const char* value, size_t size) {
  set_has_secret_code();
  if (secret_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_code_ = new ::std::string;
  }
  secret_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_verify.secret_code)
}
inline ::std::string* user_cert_lost_verify::mutable_secret_code() {
  set_has_secret_code();
  if (secret_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_verify.secret_code)
  return secret_code_;
}
inline ::std::string* user_cert_lost_verify::release_secret_code() {
  clear_has_secret_code();
  if (secret_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secret_code_;
    secret_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_cert_lost_verify::set_allocated_secret_code(::std::string* secret_code) {
  if (secret_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_code_;
  }
  if (secret_code) {
    set_has_secret_code();
    secret_code_ = secret_code;
  } else {
    clear_has_secret_code();
    secret_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_verify.secret_code)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::login_result_login_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::login_result_login_result_code>() {
  return ::proto::login_result_login_result_code_descriptor();
}
template <> struct is_proto_enum< ::proto::username_availability_result_username_availability_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::username_availability_result_username_availability_result_code>() {
  return ::proto::username_availability_result_username_availability_result_code_descriptor();
}
template <> struct is_proto_enum< ::proto::user_register_result_user_register_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::user_register_result_user_register_result_code>() {
  return ::proto::user_register_result_user_register_result_code_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
